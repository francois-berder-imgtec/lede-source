From bf4c77df324687f2348a9d6eaa230afa63582527 Mon Sep 17 00:00:00 2001
From: Damien Horsley <Damien.Horsley@imgtec.com>
Date: Mon, 2 Feb 2015 02:22:43 +0000
Subject: [PATCH 03/25] ASoC: img: Add IMG audio and event timer drivers

This commit addds following:

1. pcm3060 and pcm3168a driver

2. Event timer driver

4. ALSA startat
- Implement START_AT ioctl
- Implement start_at for system (posix) clocks using hi-res timers
- Implement start_at for audio clocks by forwarding to new fields in
	* snd_pcm_ops
	* snd_soc_ops
	* snd_soc_dai_ops
	* snd_soc_platform_driver

SNDRV_PCM_AUDIO_TSTAMP_* is taken from Pierre Louis Boussart's "Audio
Timestamping Evolutions" patchset, which has been accepted upstream.

5. add pistachio audio card drivers

Signed-off-by: Damien.Horsley <Damien.Horsley@imgtec.com>
Signed-off-by: Tim Cussins <tim.cussins@linn.co.uk>
Signed-off-by: Ian Pozella <Ian.Pozella@imgtec.com>
---
 .../bindings/sound/img,pistachio-audio.txt         |  252 ++
 .../bindings/sound/img,pistachio-event-timer.txt   |   63 +
 .../devicetree/bindings/sound/ti,pcm3060.txt       |   38 +
 .../devicetree/bindings/sound/ti,pcm3168a.txt      |   48 +
 include/dt-bindings/sound/pistachio-audio.h        |    8 +
 include/sound/dmaengine_pcm.h                      |    6 +
 include/sound/pcm.h                                |   24 +
 include/sound/soc-dai.h                            |    5 +
 include/sound/soc.h                                |    3 +
 include/uapi/sound/asound.h                        |   15 +
 kernel/time/clocksource.c                          |    1 +
 sound/core/pcm.c                                   |    4 +-
 sound/core/pcm_compat.c                            |   22 +
 sound/core/pcm_dmaengine.c                         |    3 +-
 sound/core/pcm_lib.c                               |    2 +
 sound/core/pcm_native.c                            |  241 +-
 sound/soc/codecs/Kconfig                           |   26 +
 sound/soc/codecs/Makefile                          |   12 +
 sound/soc/codecs/pcm3060-i2c.c                     |   66 +
 sound/soc/codecs/pcm3060-spi.c                     |   65 +
 sound/soc/codecs/pcm3060.c                         |  636 ++++++
 sound/soc/codecs/pcm3060.h                         |   86 +
 sound/soc/codecs/pcm3168a-i2c.c                    |   66 +
 sound/soc/codecs/pcm3168a-spi.c                    |   65 +
 sound/soc/codecs/pcm3168a.c                        |  764 +++++++
 sound/soc/codecs/pcm3168a.h                        |  111 +
 sound/soc/img/Kconfig                              |   44 +
 sound/soc/img/Makefile                             |    5 +
 sound/soc/img/pistachio-event-timer-atu.c          |   68 +
 sound/soc/img/pistachio-event-timer-internal.h     |   70 +
 sound/soc/img/pistachio-event-timer-local.c        |  186 ++
 sound/soc/img/pistachio-event-timer.c              |  995 ++++++++
 sound/soc/img/pistachio-event-timer.h              |   82 +
 sound/soc/img/pistachio.c                          | 2396 ++++++++++++++++++++
 sound/soc/soc-generic-dmaengine-pcm.c              |   79 +-
 sound/soc/soc-pcm.c                                |   89 +
 36 files changed, 6632 insertions(+), 14 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/sound/img,pistachio-audio.txt
 create mode 100644 Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt
 create mode 100644 Documentation/devicetree/bindings/sound/ti,pcm3060.txt
 create mode 100644 Documentation/devicetree/bindings/sound/ti,pcm3168a.txt
 create mode 100644 include/dt-bindings/sound/pistachio-audio.h
 create mode 100644 sound/soc/codecs/pcm3060-i2c.c
 create mode 100644 sound/soc/codecs/pcm3060-spi.c
 create mode 100644 sound/soc/codecs/pcm3060.c
 create mode 100644 sound/soc/codecs/pcm3060.h
 create mode 100644 sound/soc/codecs/pcm3168a-i2c.c
 create mode 100644 sound/soc/codecs/pcm3168a-spi.c
 create mode 100644 sound/soc/codecs/pcm3168a.c
 create mode 100644 sound/soc/codecs/pcm3168a.h
 create mode 100644 sound/soc/img/pistachio-event-timer-atu.c
 create mode 100644 sound/soc/img/pistachio-event-timer-internal.h
 create mode 100644 sound/soc/img/pistachio-event-timer-local.c
 create mode 100644 sound/soc/img/pistachio-event-timer.c
 create mode 100644 sound/soc/img/pistachio-event-timer.h
 create mode 100644 sound/soc/img/pistachio.c

--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/img,pistachio-audio.txt
@@ -0,0 +1,252 @@
+Imagination Technologies Pistachio Audio Card Driver
+
+Required properties:
+
+  - compatible : Compatible list, must contain "img,pistachio-audio"
+
+  - clocks : Contains an entry for each entry in clock-names
+
+  - clock-names : Includes the following entries:
+        "audio_pll"  The audio PLL
+        "i2s_mclk"   The i2s reference clock
+                     Also connected to i2s_out_0_mclk output
+        "dac_clk"    Dac reference clock. Connected to i2s_dac_clk output
+
+  - img,cr-periph : phandle of the peripheral control syscon
+                    node which contains the i2s loopback control registers
+
+  - img,event-timer : phandle of event timer
+
+Optional properties:
+
+  - img,widgets : Please refer to widgets.txt
+
+  - img,routing : A list of the connections between audio components.
+              Each entry is a pair of strings, the first being the
+              connection's sink, the second being the connection's
+              source
+
+  - img,mute-gpio : phandle of the mute gpio
+
+  - img,hp-det-gpio : phandle of headphone detect gpio
+
+  - img,i2s-clk-loopback : LRCLK+BCLK signals for i2s out and i2s in
+			   controllers are connected internally
+
+Optional subnodes:
+
+  - spdif-out : Contains spdif out information
+
+  - spdif-in : Contains spdif in information
+
+  - parallel-out : Contains parallel out information
+
+  - i2s-out : Contains i2s out information
+
+  - i2s-in : Contains i2s in information
+
+Required spdif-out subnode properties:
+
+  - cpu-dai : phandle of spdif out cpu dai
+
+Required spdif-in subnode properties:
+
+  - cpu-dai : phandle of spdif in cpu dai
+
+Required parallel-out subnode properties:
+
+  - cpu-dai : phandle of parallel out cpu dai
+
+  - sound-dai : phandle of internal dac
+
+Required i2s-out subnode properties:
+
+  - cpu-dai : phandle of i2s out cpu dai
+
+  - format : I2S out format. "i2s" and "left_j" are supported by
+		     the Pistachio iteration of the i2s out controller
+
+Optional i2s-out subnode properties:
+
+  - bitclock-inversion : i2s out BCLK inversion
+
+  - frame-inversion : i2s out LRCLK inversion
+
+  - continuous-clock : i2s out BCLK and LRCLK always active
+
+Optional i2s-out subnodes:
+
+  - <codec-name> : Contains codec information. <codec-name> will be used as
+		   the prefix for the codec. This name must be unique for
+		   each individual codec (unique codec device node), and
+		   cannot be equal to "internal-dac". The name
+		   should be short to avoid control name truncation
+
+Required i2s-in subnode properties:
+
+  - cpu-dai : phandle of i2s in cpu dai
+
+  - format : i2s in format. "i2s" and "left_j" are supported by
+	     the Pistachio iteration of the i2s in controller
+
+Optional i2s-in subnode properties:
+
+  - bitclock-inversion : i2s out BCLK inversion
+
+  - frame-inversion : i2s out LRCLK inversion
+
+  - continuous-clock : i2s out BCLK and LRCLK always active
+
+Optional i2s-in subnodes:
+
+  - <codec-name> : Contains codec information. <codec-name> will be used as
+		   the prefix for the codec. This name must be unique for
+		   each individual codec (unique codec device node), and
+		   cannot be equal to "internal-dac". The name
+		   should be short to avoid control name truncation
+
+Required <codec-name> subnode properties:
+
+  - mclk : Contains the mclk (master clock) used by the DAC/ADC.
+	   Valid identifiers (dt-bindings/sound/pistachio-audio.h):
+
+	       PISTACHIO_MCLK_NONE      No mclk is required, or mclk is
+					provided externally with no software
+					intervention required to compenstate
+					for differing sample rates
+
+	       PISTACHIO_MCLK_I2S       mclk is provided by the i2s_out_0_mclk
+					output from pistachio SoC. This clock
+					is shared with the internal i2s out
+					controller
+
+	       PISTACHIO_MCLK_DAC_CLK   mclk is provided by the i2s_dac_clk
+					output from pistachio SoC
+
+Required <codec-name> subnode properties if mclk is not PISTACHIO_MCLK_NONE:
+
+  - mclk-fs : Contains the set of fs ratios the DAC/ADC accepts (Nfs for
+	      sample rate r specifies the master clock input to the DAC is
+	      N times r). It is assumed this set of ratios is applicable to
+	      any given sample rate where this does not lead to a violation
+	      of the minimum/maximum frequencies specified by mclk-min-freq
+	      and mclk-max-freq respectively
+
+  - mclk-min-freq : Contains the minimum frequency the DAC/ADC accepts for
+		    its master clock input
+
+  - mclk-max-freq : Contains the maximum frequency the DAC/ADC accepts for
+		    its master clock input
+
+Optional <codec-name> subnode properties:
+
+  - sound-dai : phandle of the codec. If the codec does not accept/require
+		software configuration, this can be omitted
+
+  - mclk-index : Index of the mclk, used for snd_soc_dai_set_sysclk call.
+		 0 is used if this property is omitted
+
+  - frame-master : Indicates this codec is the LRCLK master
+
+  - bitclock-master : Indicates this codec is the BCLK master
+
+  frame-master and bitclock-master cannot exist in more than one of the codec
+  subnodes
+
+  frame-master and bitclock-master cannot be used within i2s out codec subnodes
+  as the Pistachio iteration of the i2s out controller accepts master mode
+  only
+
+  frame-master and bitclock-master can be omitted if img,i2s-clk-loopback is
+  used, or if LRCLK/BCLK generation does not require software intervention (eg
+  a codec operating in hardware-mode)
+
+Example 1 (Pistachio Bring-Up Board With Codec Daughterboard Inserted):
+
+All audio components present on board. 2x pcm3168a codecs provide 3 i2s in
+and out channels each. dac_clk provides the single master clock to both
+codecs. The Pistachio i2s out controller is the LRCLK+BCLK master for the DAC
+path. The second pcm3168a codec is the LRCLK+BCLK master for the ADC path
+
+pistachio_audio_card {
+	compatible = "img,pistachio-audio";
+
+	clocks = <&clk_core CLK_AUDIO_PLL>,
+		 <&clk_core CLK_I2S_DIV>,
+		 <&clk_core CLK_AUDIO>;
+	clock-names = "audio_pll", "i2s_mclk", "dac_clk";
+
+	img,cr-periph = <&cr_periph>;
+	img,event-timer = <&event_timer>;
+
+	img,mute-gpio = <&gpio5 1 GPIO_ACTIVE_LOW>;
+	img,hp-det-gpio = <&gpio5 3 GPIO_ACTIVE_LOW>;
+
+	img,widgets = "Headphone", "Headphones",
+		      "Speaker", "Speakers",
+		      "Line", "RCA Out";
+
+	img,routing = "Headphones", "internal-dac AOUTL",
+		      "Headphones", "internal-dac AOUTR",
+		      "Speakers", "internal-dac AOUTL",
+		      "Speakers", "internal-dac AOUTR",
+		      "RCA Out", "internal-dac AOUTL",
+		      "RCA Out", "internal-dac AOUTR";
+
+	spdif-out {
+		cpu-dai = <&spdif_out>;
+	};
+
+	spdif-in {
+		cpu-dai = <&spdif_in>;
+	};
+
+	parallel-out {
+		cpu-dai = <&parallel_out>;
+		sound-dai = <&internal_dac>;
+	};
+
+	i2s-out {
+		cpu-dai = <&i2s_out>;
+		format = "i2s";
+
+		pcm3168a-1 {
+			mclk = <PISTACHIO_MCLK_DAC_CLK>;
+			mclk-fs = <128 192 256 384 512 768>;
+			mclk-min-freq = <2048000>;
+			mclk-max-freq = <36864000>;
+			sound-dai = <&pcm3168a_1 0>;
+		};
+
+		pcm3168a-2 {
+			mclk = <PISTACHIO_MCLK_DAC_CLK>;
+			mclk-fs = <128 192 256 384 512 768>;
+			mclk-min-freq = <2048000>;
+			mclk-max-freq = <36864000>;
+			sound-dai = <&pcm3168a_2 0>;
+		};
+	};
+
+	i2s-in {
+		cpu-dai = <&i2s_in>;
+		format = "i2s";
+
+		pcm3168a-1 {
+			mclk = <PISTACHIO_MCLK_DAC_CLK>;
+			mclk-fs = <256 384 512 768>;
+			mclk-min-freq = <2048000>;
+			mclk-max-freq = <36864000>;
+			sound-dai = <&pcm3168a_1 1>;
+		};
+
+		pcm3168a-2 {
+			mclk = <PISTACHIO_MCLK_DAC_CLK>;
+			mclk-fs = <256 384 512 768>;
+			mclk-min-freq = <2048000>;
+			mclk-max-freq = <36864000>;
+			sound-dai = <&pcm3168a_2 1>;
+			frame-master;
+			bitclock-master;
+		};
+	};
+};
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt
@@ -0,0 +1,63 @@
+Imagination Technologies Pistachio Event Timer
+
+Required properties:
+
+  - compatible : Compatible list, must contain "img,pistachio-event-timer"
+
+  - reg : Offset and length of the register set for the device
+
+  - interrupts : Must contain an entry for each of the three interrupts below.
+		 Order must also match the below:
+
+		 Internal interrupt 1
+		 Internal interrupt 2
+		 Internal interrupt 3
+		 Event trigger 0
+		 Event trigger 1
+
+  - #clock-cells : Must be 0
+
+  - clocks : Must contain an entry for each entry in clock-names
+	See ../clock/clock-bindings.txt for details
+
+  - clock-names : Must include the following entries:
+	"sys"	The system clock
+	"ref0"	Reference clock 0
+	"ref1"	Reference clock 1
+	"pll"	Audio PLL
+
+  - img,clk-select : Reference select
+
+  - img,cr-periph : phandle of the peripheral control syscon node which
+		    contains the event timer external source bank select
+		    register
+
+  - img,ext-src-bank : GPIO bank selection for external source. For this source
+		       to function correctly, no other input gpios must be used
+		       within the selected GPIO bank
+
+Optional properties:
+
+  - img,clk-rate : Initial internal clock rate
+
+Example:
+
+event_timer: event_timer@18102300 {
+	compatible = "img,pistachio-event-timer";
+	reg = <0x18102300 0x400>;
+	assigned-clocks = <&clk_core CLK_EVENT_TIMER_MUX>;
+	assigned-clock-parents = <&clk_core CLK_AUDIO_PLL_MUX>;
+	interrupts = <GIC_SHARED 53 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SHARED 54 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SHARED 55 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SHARED 56 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SHARED 57 IRQ_TYPE_LEVEL_HIGH>;
+	#clock-cells = <0>;
+	clocks = <&clk_core SYS_CLK_EVENT_TIMER>,
+		 <&clk_core CLK_AUDIO>,
+		 <&clk_core CLK_EVENT_TIMER>,
+		 <&clk_core CLK_AUDIO_PLL>;
+	clock-names = "sys","ref0","ref1", "pll";
+	img,clk-select = <1>;
+	img,clk-rate = <12288000>;
+};
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/ti,pcm3060.txt
@@ -0,0 +1,38 @@
+Texas Instruments pcm3060 DT bindings
+
+This driver supports both SPI and I2C bus access for this codec
+
+Required properties:
+
+  - compatible: "ti,pcm3060"
+
+  - clocks : Contains an entry for each entry in clock-names
+
+  - clock-names : Includes the following entries:
+	"sckid"	The DAC system clock
+	"sckia"	The ADC system clock
+
+  - VDD-supply : Digital power supply regulator (+3.3V)
+
+  - VCC-supply : Analogue power supply regulator (+5V)
+
+For required properties on SPI/I2C, consult SPI/I2C device tree documentation
+
+Examples:
+
+i2c0: i2c0@0 {
+
+	...
+
+	pcm3060: audio-codec@46 {
+		compatible = "ti,pcm3060";
+		reg = <0x46>;
+		clocks = <&clk_core CLK_I2S>,
+			 <&clk_core CLK_I2S>;
+		clock-names = "sckid", "sckia";
+		VCC-supply = <&supply5v0>;
+		VDD-supply = <&supply3v3>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s_mclk_pin>;
+	};
+};
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/ti,pcm3168a.txt
@@ -0,0 +1,48 @@
+Texas Instruments pcm3168a DT bindings
+
+This driver supports both SPI and I2C bus access for this codec
+
+Required properties:
+
+  - compatible: "ti,pcm3168a"
+
+  - clocks : Contains an entry for each entry in clock-names
+
+  - clock-names : Includes the following entries:
+	"scki"	The system clock
+
+  - VDD1-supply : Digital power supply regulator 1 (+3.3V)
+
+  - VDD2-supply : Digital power supply regulator 2 (+3.3V)
+
+  - VCCAD1-supply : ADC power supply regulator 1 (+5V)
+
+  - VCCAD2-supply : ADC power supply regulator 2 (+5V)
+
+  - VCCDA1-supply : DAC power supply regulator 1 (+5V)
+
+  - VCCDA2-supply : DAC power supply regulator 2 (+5V)
+
+For required properties on SPI/I2C, consult SPI/I2C device tree documentation
+
+Examples:
+
+i2c0: i2c0@0 {
+
+	...
+
+	pcm3168a: audio-codec@44 {
+		compatible = "ti,pcm3168a";
+		reg = <0x44>;
+		clocks = <&clk_core CLK_AUDIO>;
+		clock-names = "scki";
+		VDD1-supply = <&supply3v3>;
+		VDD2-supply = <&supply3v3>;
+		VCCAD1-supply = <&supply5v0>;
+		VCCAD2-supply = <&supply5v0>;
+		VCCDA1-supply = <&supply5v0>;
+		VCCDA2-supply = <&supply5v0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&dac_clk_pin>;
+	};
+};
--- /dev/null
+++ b/include/dt-bindings/sound/pistachio-audio.h
@@ -0,0 +1,8 @@
+#ifndef __PISTACHIO_BUB_AUDIO_H
+#define __PISTACHIO_BUB_AUDIO_H
+
+#define PISTACHIO_MCLK_NONE		0
+#define PISTACHIO_MCLK_I2S		1
+#define PISTACHIO_MCLK_DAC		2
+
+#endif
--- a/include/sound/dmaengine_pcm.h
+++ b/include/sound/dmaengine_pcm.h
@@ -35,6 +35,7 @@ snd_pcm_substream_to_dma_direction(const
 
 int snd_hwparams_to_dma_slave_config(const struct snd_pcm_substream *substream,
 	const struct snd_pcm_hw_params *params, struct dma_slave_config *slave_config);
+int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream);
 int snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd);
 snd_pcm_uframes_t snd_dmaengine_pcm_pointer(struct snd_pcm_substream *substream);
 snd_pcm_uframes_t snd_dmaengine_pcm_pointer_no_residue(struct snd_pcm_substream *substream);
@@ -99,6 +100,11 @@ void snd_dmaengine_pcm_set_config_from_d
  * The PCM streams have custom channel names specified.
  */
 #define SND_DMAENGINE_PCM_FLAG_CUSTOM_CHANNEL_NAME BIT(4)
+/*
+ * DMA needs to be started early when start_at is used (eg to allow pre-loading
+ * of internal fifos before assertion of an enable signal)
+ */
+#define SND_DMAENGINE_PCM_FLAG_EARLY_START BIT(5)
 
 /**
  * struct snd_dmaengine_pcm_config - Configuration data for dmaengine based PCM
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -30,6 +30,9 @@
 #include <linux/mm.h>
 #include <linux/bitops.h>
 #include <linux/pm_qos.h>
+#if defined(CONFIG_HIGH_RES_TIMERS)
+#include <linux/hrtimer.h>
+#endif
 
 #define snd_pcm_substream_chip(substream) ((substream)->private_data)
 #define snd_pcm_chip(pcm) ((pcm)->private_data)
@@ -73,6 +76,9 @@ struct snd_pcm_ops {
 	int (*hw_free)(struct snd_pcm_substream *substream);
 	int (*prepare)(struct snd_pcm_substream *substream);
 	int (*trigger)(struct snd_pcm_substream *substream, int cmd);
+	int (*start_at)(struct snd_pcm_substream *substream,
+		int audio_clock_type, const struct timespec *ts);
+	int (*start_at_abort)(struct snd_pcm_substream *substream);
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream);
 	int (*get_time_info)(struct snd_pcm_substream *substream,
 			struct timespec *system_ts, struct timespec *audio_ts,
@@ -422,6 +428,7 @@ struct snd_pcm_runtime {
 	/* -- OSS things -- */
 	struct snd_pcm_oss_runtime oss;
 #endif
+
 };
 
 struct snd_pcm_group {		/* keep linked substreams */
@@ -482,6 +489,16 @@ struct snd_pcm_substream {
 #endif /* CONFIG_SND_VERBOSE_PROCFS */
 	/* misc flags */
 	unsigned int hw_opened: 1;
+	/* start at wait queue */
+	wait_queue_head_t start_at_wait;
+	/* start at status info */
+	bool start_at_pending;
+	/* Clock type for pending start at */
+	int start_at_clock_class;
+#ifdef CONFIG_HIGH_RES_TIMERS
+	/* start at timer for use with system startat */
+	struct hrtimer start_at_timer;
+#endif
 };
 
 #define SUBSTREAM_BUSY(substream) ((substream)->ref_count > 0)
@@ -564,6 +581,10 @@ int snd_pcm_info_user(struct snd_pcm_sub
 int snd_pcm_status(struct snd_pcm_substream *substream,
 		   struct snd_pcm_status *status);
 int snd_pcm_start(struct snd_pcm_substream *substream);
+int snd_pcm_pre_start(struct snd_pcm_substream *substream, int state);
+int snd_pcm_do_start(struct snd_pcm_substream *substream, int state);
+void snd_pcm_undo_start(struct snd_pcm_substream *substream, int state);
+void snd_pcm_post_start(struct snd_pcm_substream *substream, int state);
 int snd_pcm_stop(struct snd_pcm_substream *substream, snd_pcm_state_t status);
 int snd_pcm_drain_done(struct snd_pcm_substream *substream);
 int snd_pcm_stop_xrun(struct snd_pcm_substream *substream);
@@ -1086,6 +1107,9 @@ snd_pcm_sframes_t snd_pcm_lib_writev(str
 snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 				    void __user **bufs, snd_pcm_uframes_t frames);
 
+void snd_pcm_start_at_trigger(struct snd_pcm_substream *substream);
+void snd_pcm_start_at_cleanup(struct snd_pcm_substream *substream);
+
 extern const struct snd_pcm_hw_constraint_list snd_pcm_known_rates;
 
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
--- a/include/sound/soc-dai.h
+++ b/include/sound/soc-dai.h
@@ -205,6 +205,11 @@ struct snd_soc_dai_ops {
 	 */
 	snd_pcm_sframes_t (*delay)(struct snd_pcm_substream *,
 		struct snd_soc_dai *);
+
+	int (*start_at)(struct snd_pcm_substream *, struct snd_soc_dai *,
+		int, const struct timespec *);
+	int (*start_at_abort)(struct snd_pcm_substream *,
+		struct snd_soc_dai *);
 };
 
 /*
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@ -737,6 +737,9 @@ struct snd_soc_ops {
 	int (*hw_free)(struct snd_pcm_substream *);
 	int (*prepare)(struct snd_pcm_substream *);
 	int (*trigger)(struct snd_pcm_substream *, int);
+	int (*start_at)(struct snd_pcm_substream *, int,
+		const struct timespec *);
+	int (*start_at_abort)(struct snd_pcm_substream *);
 };
 
 struct snd_soc_compr_ops {
--- a/include/uapi/sound/asound.h
+++ b/include/uapi/sound/asound.h
@@ -293,6 +293,7 @@ typedef int __bitwise snd_pcm_state_t;
 #define	SNDRV_PCM_STATE_PAUSED		((__force snd_pcm_state_t) 6) /* stream is paused */
 #define	SNDRV_PCM_STATE_SUSPENDED	((__force snd_pcm_state_t) 7) /* hardware is suspended */
 #define	SNDRV_PCM_STATE_DISCONNECTED	((__force snd_pcm_state_t) 8) /* hardware is disconnected */
+#define	SNDRV_PCM_STATE_STARTING	((__force snd_pcm_state_t) 9) /* stream start has been delegated to the kernel */
 #define	SNDRV_PCM_STATE_LAST		SNDRV_PCM_STATE_DISCONNECTED
 
 enum {
@@ -503,6 +504,18 @@ enum {
 	SNDRV_PCM_TSTAMP_TYPE_LAST = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW,
 };
 
+enum {
+	SNDRV_PCM_CLOCK_CLASS_SYSTEM = 0,
+	SNDRV_PCM_CLOCK_CLASS_AUDIO,
+	SNDRV_PCM_CLOCK_CLASS_LAST = SNDRV_PCM_CLOCK_CLASS_AUDIO,
+};
+
+struct snd_startat {
+	int clock_class;
+	int clock_type;
+	struct timespec start_time;
+};
+
 /* channel positions */
 enum {
 	SNDRV_CHMAP_UNKNOWN = 0,
@@ -582,6 +595,8 @@ enum {
 #define SNDRV_PCM_IOCTL_READN_FRAMES	_IOR('A', 0x53, struct snd_xfern)
 #define SNDRV_PCM_IOCTL_LINK		_IOW('A', 0x60, int)
 #define SNDRV_PCM_IOCTL_UNLINK		_IO('A', 0x61)
+#define SNDRV_PCM_IOCTL_START_AT        _IOW('A', 0x62, struct snd_startat)
+
 
 /*****************************************************************************
  *                                                                           *
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@ -89,6 +89,7 @@ clocks_calc_mult_shift(u32 *mult, u32 *s
 	*mult = tmp;
 	*shift = sft;
 }
+EXPORT_SYMBOL(clocks_calc_mult_shift);
 
 /*[Clocksource internal variables]---------
  * curr_clocksource:
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -489,7 +489,8 @@ static void snd_pcm_xrun_injection_write
 
 	snd_pcm_stream_lock_irq(substream);
 	runtime = substream->runtime;
-	if (runtime && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+	if (runtime && (runtime->status->state == SNDRV_PCM_STATE_RUNNING ||
+			runtime->status->state == SNDRV_PCM_STATE_STARTING))
 		snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 	snd_pcm_stream_unlock_irq(substream);
 }
@@ -746,6 +747,7 @@ int snd_pcm_new_stream(struct snd_pcm *p
 		INIT_LIST_HEAD(&substream->self_group.substreams);
 		list_add_tail(&substream->link_list, &substream->self_group.substreams);
 		atomic_set(&substream->mmap_count, 0);
+		init_waitqueue_head(&substream->start_at_wait);
 		prev = substream;
 	}
 	return 0;
--- a/sound/core/pcm_compat.c
+++ b/sound/core/pcm_compat.c
@@ -316,6 +316,25 @@ static int snd_pcm_status_user_x32(struc
 }
 #endif /* CONFIG_X86_X32 */
 
+struct snd_startat32 {
+	u32 clock_class;
+	u32 clock_type;
+	struct compat_timespec start_time;
+} __packed;
+
+static int snd_pcm_start_at_compat(struct snd_pcm_substream *substream,
+					struct snd_startat32 __user *_start_at)
+{
+	struct snd_startat start_at;
+
+	if (get_user(start_at.clock_class, &_start_at.clock_class) ||
+	    get_user(start_at.clock_type, &_start_at.clock_type) ||
+	    compat_get_timespec(&start_at.start_time, &_start_at.start_time))
+		return -EFAULT;
+
+	return snd_pcm_start_at(substream, &start_at);
+}
+
 /* both for HW_PARAMS and HW_REFINE */
 static int snd_pcm_ioctl_hw_params_compat(struct snd_pcm_substream *substream,
 					  int refine, 
@@ -653,6 +672,7 @@ enum {
 	SNDRV_PCM_IOCTL_STATUS_EXT_X32 = _IOWR('A', 0x24, struct snd_pcm_status_x32),
 	SNDRV_PCM_IOCTL_SYNC_PTR_X32 = _IOWR('A', 0x23, struct snd_pcm_sync_ptr_x32),
 #endif /* CONFIG_X86_X32 */
+	SNDRV_PCM_IOCTL_START_AT32 = _IOWR('A', 0x62, struct snd_startat32)
 };
 
 static long snd_pcm_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)
@@ -734,6 +754,8 @@ static long snd_pcm_ioctl_compat(struct
 	case SNDRV_PCM_IOCTL_CHANNEL_INFO_X32:
 		return snd_pcm_ioctl_channel_info_x32(substream, argp);
 #endif /* CONFIG_X86_X32 */
+	case SNDRV_PCM_IOCTL_START_AT32:
+		return snd_pcm_start_at_compat(substream, argp);
 	}
 
 	return -ENOIOCTLCMD;
--- a/sound/core/pcm_dmaengine.c
+++ b/sound/core/pcm_dmaengine.c
@@ -142,7 +142,7 @@ static void dmaengine_pcm_dma_complete(v
 	snd_pcm_period_elapsed(substream);
 }
 
-static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
+int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 {
 	struct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);
 	struct dma_chan *chan = prtd->dma_chan;
@@ -170,6 +170,7 @@ static int dmaengine_pcm_prepare_and_sub
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(dmaengine_pcm_prepare_and_submit);
 
 /**
  * snd_dmaengine_pcm_trigger - dmaengine based PCM trigger implementation
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2025,6 +2025,7 @@ static snd_pcm_sframes_t snd_pcm_lib_wri
 	snd_pcm_stream_lock_irq(substream);
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_PREPARED:
+	case SNDRV_PCM_STATE_STARTING:
 	case SNDRV_PCM_STATE_RUNNING:
 	case SNDRV_PCM_STATE_PAUSED:
 		break;
@@ -2251,6 +2252,7 @@ static snd_pcm_sframes_t snd_pcm_lib_rea
 		break;
 	case SNDRV_PCM_STATE_DRAINING:
 	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_STARTING:
 	case SNDRV_PCM_STATE_PAUSED:
 		break;
 	case SNDRV_PCM_STATE_XRUN:
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -35,6 +35,9 @@
 #include <sound/timer.h>
 #include <sound/minors.h>
 #include <linux/uio.h>
+#if defined(CONFIG_HIGH_RES_TIMERS)
+#include <linux/hrtimer.h>
+#endif
 
 /*
  *  Compatibility
@@ -277,7 +280,7 @@ static const char * const snd_pcm_hw_par
 };
 #endif
 
-int snd_pcm_hw_refine(struct snd_pcm_substream *substream, 
+int snd_pcm_hw_refine(struct snd_pcm_substream *substream,
 		      struct snd_pcm_hw_params *params)
 {
 	unsigned int k;
@@ -1028,7 +1031,7 @@ static int snd_pcm_action_nonatomic(stru
 /*
  * start callbacks
  */
-static int snd_pcm_pre_start(struct snd_pcm_substream *substream, int state)
+int snd_pcm_pre_start(struct snd_pcm_substream *substream, int state)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	if (runtime->status->state != SNDRV_PCM_STATE_PREPARED)
@@ -1040,21 +1043,24 @@ static int snd_pcm_pre_start(struct snd_
 	runtime->trigger_master = substream;
 	return 0;
 }
+EXPORT_SYMBOL_GPL(snd_pcm_pre_start);
 
-static int snd_pcm_do_start(struct snd_pcm_substream *substream, int state)
+int snd_pcm_do_start(struct snd_pcm_substream *substream, int state)
 {
 	if (substream->runtime->trigger_master != substream)
 		return 0;
 	return substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_START);
 }
+EXPORT_SYMBOL_GPL(snd_pcm_do_start);
 
-static void snd_pcm_undo_start(struct snd_pcm_substream *substream, int state)
+void snd_pcm_undo_start(struct snd_pcm_substream *substream, int state)
 {
 	if (substream->runtime->trigger_master == substream)
 		substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_STOP);
 }
+EXPORT_SYMBOL_GPL(snd_pcm_undo_start);
 
-static void snd_pcm_post_start(struct snd_pcm_substream *substream, int state)
+void snd_pcm_post_start(struct snd_pcm_substream *substream, int state)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_trigger_tstamp(substream);
@@ -1067,6 +1073,7 @@ static void snd_pcm_post_start(struct sn
 		snd_pcm_playback_silence(substream, ULONG_MAX);
 	snd_pcm_timer_notify(substream, SNDRV_TIMER_EVENT_MSTART);
 }
+EXPORT_SYMBOL_GPL(snd_pcm_post_start);
 
 static struct action_ops snd_pcm_action_start = {
 	.pre_action = snd_pcm_pre_start,
@@ -1075,6 +1082,185 @@ static struct action_ops snd_pcm_action_
 	.post_action = snd_pcm_post_start
 };
 
+void snd_pcm_start_at_cleanup(struct snd_pcm_substream *substream)
+{
+	substream->start_at_pending = 0;
+	wake_up(&substream->start_at_wait);
+}
+EXPORT_SYMBOL_GPL(snd_pcm_start_at_cleanup);
+
+void snd_pcm_start_at_trigger(struct snd_pcm_substream *substream)
+{
+	snd_pcm_stream_lock(substream);
+
+	if(substream->runtime->status->state == SNDRV_PCM_STATE_STARTING)
+		if(!snd_pcm_do_start(substream, SNDRV_PCM_STATE_RUNNING))
+			snd_pcm_post_start(substream, SNDRV_PCM_STATE_RUNNING);
+
+	snd_pcm_start_at_cleanup(substream);
+
+	snd_pcm_stream_unlock(substream);
+}
+EXPORT_SYMBOL_GPL(snd_pcm_start_at_trigger);
+
+#ifdef CONFIG_HIGH_RES_TIMERS
+static enum hrtimer_restart snd_pcm_do_start_time(struct hrtimer *timer)
+{
+	struct snd_pcm_substream *substream;
+
+	substream = container_of(timer, struct snd_pcm_substream,
+					start_at_timer);
+
+	snd_pcm_start_at_trigger(substream);
+
+	return HRTIMER_NORESTART;
+}
+#endif
+
+static int snd_pcm_startat_system(struct snd_pcm_substream *substream,
+	int clock_type, const struct timespec *start_time)
+{
+#ifdef CONFIG_HIGH_RES_TIMERS
+	struct timespec now;
+	clockid_t clock;
+
+	switch (clock_type) {
+	case SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY:
+		clock = CLOCK_REALTIME;
+		getnstimeofday(&now);
+		break;
+	case SNDRV_PCM_TSTAMP_TYPE_MONOTONIC:
+		clock = CLOCK_MONOTONIC;
+		ktime_get_ts(&now);
+		break;
+	default: /* unsupported clocks bounce off */
+		return -ENOSYS;
+	}
+
+	/* Check if start_time is in the past */
+	if (timespec_compare(&now, start_time) >= 0)
+		return -ETIME;
+
+	hrtimer_init(&substream->start_at_timer, clock, HRTIMER_MODE_ABS);
+	substream->start_at_timer.function = snd_pcm_do_start_time;
+
+	hrtimer_start(&substream->start_at_timer,
+			timespec_to_ktime(*start_time), HRTIMER_MODE_ABS);
+
+	return 0;
+#else
+	return -ENOSYS;
+#endif
+}
+
+static void snd_pcm_startat_system_cancel(struct snd_pcm_substream *substream)
+{
+#ifdef CONFIG_HIGH_RES_TIMERS
+	if(hrtimer_try_to_cancel(&substream->start_at_timer) == 1)
+		snd_pcm_start_at_cleanup(substream);
+#endif
+}
+
+static int snd_pcm_startat_audio(struct snd_pcm_substream *substream,
+	int clock_type, const struct timespec *start_time)
+{
+	if (substream->ops->start_at)
+		return substream->ops->start_at(substream, clock_type,
+			start_time);
+	else
+		return -ENOSYS;
+}
+
+static void snd_pcm_startat_audio_cancel(struct snd_pcm_substream *substream)
+{
+	if (substream->ops->start_at_abort)
+		substream->ops->start_at_abort(substream);
+}
+
+static int snd_pcm_start_at(struct snd_pcm_substream *substream,
+	struct snd_startat *start_at)
+{
+	int ret;
+
+	if (!timespec_valid(&start_at->start_time))
+		return -EINVAL;
+
+	snd_pcm_stream_lock(substream);
+
+	if(substream->start_at_pending) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	ret = snd_pcm_pre_start(substream, SNDRV_PCM_STATE_PREPARED);
+	if (ret < 0)
+		goto end;
+
+	switch (start_at->clock_class) {
+	case SNDRV_PCM_CLOCK_CLASS_SYSTEM:
+		ret = snd_pcm_startat_system(substream,
+			start_at->clock_type,
+			&start_at->start_time);
+		break;
+	case SNDRV_PCM_CLOCK_CLASS_AUDIO:
+		ret = snd_pcm_startat_audio(substream,
+			start_at->clock_type,
+			&start_at->start_time);
+		if(ret)
+			snd_pcm_startat_audio_cancel(substream);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	if (!ret) {
+		substream->runtime->status->state = SNDRV_PCM_STATE_STARTING;
+		substream->start_at_pending = true;
+		substream->start_at_clock_class = start_at->clock_class;
+	}
+
+end:
+	snd_pcm_stream_unlock(substream);
+	return ret;
+}
+
+static void snd_pcm_startat_cancel(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	if (runtime->status->state != SNDRV_PCM_STATE_STARTING)
+		return;
+
+	switch (substream->start_at_clock_class) {
+	case SNDRV_PCM_CLOCK_CLASS_SYSTEM:
+		snd_pcm_startat_system_cancel(substream);
+		break;
+	case SNDRV_PCM_CLOCK_CLASS_AUDIO:
+		snd_pcm_startat_audio_cancel(substream);
+		break;
+	default:
+		return;
+	}
+
+	runtime->status->state = SNDRV_PCM_STATE_SETUP;
+
+	wait_event_cmd(substream->start_at_wait,
+			!substream->start_at_pending,
+			snd_pcm_stream_unlock(substream),
+			snd_pcm_stream_lock(substream));
+}
+
+int snd_pcm_start_at_user(struct snd_pcm_substream *substream,
+	struct snd_startat __user *_start_at_user)
+{
+	struct snd_startat start_at;
+
+	if (copy_from_user(&start_at, _start_at_user, sizeof(start_at)))
+		return -EFAULT;
+
+	return snd_pcm_start_at(substream, &start_at);
+}
+
 /**
  * snd_pcm_start - start all linked streams
  * @substream: the PCM substream instance
@@ -1101,9 +1287,21 @@ static int snd_pcm_pre_stop(struct snd_p
 
 static int snd_pcm_do_stop(struct snd_pcm_substream *substream, int state)
 {
-	if (substream->runtime->trigger_master == substream &&
-	    snd_pcm_running(substream))
-		substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_STOP);
+	if (substream->runtime->trigger_master == substream) {
+		switch(substream->runtime->status->state) {
+		case SNDRV_PCM_STATE_STARTING:
+			snd_pcm_startat_cancel(substream);
+			break;
+		case SNDRV_PCM_STATE_RUNNING:
+		case SNDRV_PCM_STATE_DRAINING:
+			substream->ops->trigger(substream,
+				SNDRV_PCM_TRIGGER_STOP);
+			break;
+		default:
+			break;
+		}
+	}
+
 	return 0; /* unconditonally stop all substreams */
 }
 
@@ -1167,11 +1365,13 @@ int snd_pcm_drain_done(struct snd_pcm_su
  */
 int snd_pcm_stop_xrun(struct snd_pcm_substream *substream)
 {
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned long flags;
 	int ret = 0;
 
 	snd_pcm_stream_lock_irqsave(substream, flags);
-	if (snd_pcm_running(substream))
+	if (snd_pcm_running(substream) ||
+			runtime->status->state == SNDRV_PCM_STATE_STARTING)
 		ret = snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	return ret;
@@ -1257,7 +1457,8 @@ static int snd_pcm_pause(struct snd_pcm_
 static int snd_pcm_pre_suspend(struct snd_pcm_substream *substream, int state)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	if (runtime->status->state == SNDRV_PCM_STATE_SUSPENDED)
+	if ((runtime->status->state == SNDRV_PCM_STATE_SUSPENDED) ||
+			(runtime->status->state == SNDRV_PCM_STATE_STARTING))
 		return -EBUSY;
 	runtime->trigger_master = substream;
 	return 0;
@@ -1355,6 +1556,8 @@ static int snd_pcm_pre_resume(struct snd
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	if (!(runtime->info & SNDRV_PCM_INFO_RESUME))
 		return -ENOSYS;
+	if (runtime->status->state == SNDRV_PCM_STATE_STARTING)
+		return -EBUSY;
 	runtime->trigger_master = substream;
 	return 0;
 }
@@ -1439,6 +1642,7 @@ static int snd_pcm_xrun(struct snd_pcm_s
 		result = 0;	/* already there */
 		break;
 	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_STARTING:
 		result = snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 		break;
 	default:
@@ -1458,6 +1662,7 @@ static int snd_pcm_pre_reset(struct snd_
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_STARTING:
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_PAUSED:
 	case SNDRV_PCM_STATE_SUSPENDED:
@@ -1512,7 +1717,8 @@ static int snd_pcm_pre_prepare(struct sn
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN ||
 	    runtime->status->state == SNDRV_PCM_STATE_DISCONNECTED)
 		return -EBADFD;
-	if (snd_pcm_running(substream))
+	if (snd_pcm_running(substream) ||
+	    runtime->status->state == SNDRV_PCM_STATE_STARTING)
 		return -EBUSY;
 	substream->f_flags = f_flags;
 	return 0;
@@ -1578,6 +1784,7 @@ static int snd_pcm_pre_drain_init(struct
 	case SNDRV_PCM_STATE_OPEN:
 	case SNDRV_PCM_STATE_DISCONNECTED:
 	case SNDRV_PCM_STATE_SUSPENDED:
+	case SNDRV_PCM_STATE_STARTING:
 		return -EBADFD;
 	}
 	runtime->trigger_master = substream;
@@ -1782,6 +1989,7 @@ static int snd_pcm_drop(struct snd_pcm_s
 		snd_pcm_pause(substream, 0);
 
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
+
 	/* runtime->control->appl_ptr = runtime->status->hw_ptr; */
 	snd_pcm_stream_unlock_irq(substream);
 
@@ -2234,6 +2442,7 @@ void snd_pcm_release_substream(struct sn
 		return;
 
 	snd_pcm_drop(substream);
+
 	if (substream->hw_opened) {
 		if (substream->ops->hw_free &&
 		    substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)
@@ -2441,6 +2650,7 @@ static snd_pcm_sframes_t snd_pcm_playbac
 	snd_pcm_stream_lock_irq(substream);
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_PREPARED:
+	case SNDRV_PCM_STATE_STARTING:
 		break;
 	case SNDRV_PCM_STATE_DRAINING:
 	case SNDRV_PCM_STATE_RUNNING:
@@ -2490,6 +2700,7 @@ static snd_pcm_sframes_t snd_pcm_capture
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_DRAINING:
+	case SNDRV_PCM_STATE_STARTING:
 		break;
 	case SNDRV_PCM_STATE_RUNNING:
 		if (snd_pcm_update_hw_ptr(substream) >= 0)
@@ -2538,6 +2749,7 @@ static snd_pcm_sframes_t snd_pcm_playbac
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_PAUSED:
+	case SNDRV_PCM_STATE_STARTING:
 		break;
 	case SNDRV_PCM_STATE_DRAINING:
 	case SNDRV_PCM_STATE_RUNNING:
@@ -2588,6 +2800,7 @@ static snd_pcm_sframes_t snd_pcm_capture
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_DRAINING:
 	case SNDRV_PCM_STATE_PAUSED:
+	case SNDRV_PCM_STATE_STARTING:
 		break;
 	case SNDRV_PCM_STATE_RUNNING:
 		if (snd_pcm_update_hw_ptr(substream) >= 0)
@@ -2638,6 +2851,7 @@ static int snd_pcm_hwsync(struct snd_pcm
 		/* Fall through */
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_SUSPENDED:
+	case SNDRV_PCM_STATE_STARTING:
 		err = 0;
 		break;
 	case SNDRV_PCM_STATE_XRUN:
@@ -2671,6 +2885,7 @@ static int snd_pcm_delay(struct snd_pcm_
 		/* Fall through */
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_SUSPENDED:
+	case SNDRV_PCM_STATE_STARTING:
 		err = 0;
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 			n = snd_pcm_playback_hw_avail(runtime);
@@ -2781,6 +2996,8 @@ static int snd_pcm_common_ioctl1(struct
 		return snd_pcm_action_lock_irq(&snd_pcm_action_start, substream, SNDRV_PCM_STATE_RUNNING);
 	case SNDRV_PCM_IOCTL_LINK:
 		return snd_pcm_link(substream, (int)(unsigned long) arg);
+	case SNDRV_PCM_IOCTL_START_AT:
+		return snd_pcm_start_at(substream, arg);
 	case SNDRV_PCM_IOCTL_UNLINK:
 		return snd_pcm_unlink(substream);
 	case SNDRV_PCM_IOCTL_RESUME:
@@ -3172,6 +3389,7 @@ static unsigned int snd_pcm_playback_pol
 	case SNDRV_PCM_STATE_RUNNING:
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_PAUSED:
+	case SNDRV_PCM_STATE_STARTING:
 		if (avail >= runtime->control->avail_min) {
 			mask = POLLOUT | POLLWRNORM;
 			break;
@@ -3209,6 +3427,7 @@ static unsigned int snd_pcm_capture_poll
 	avail = snd_pcm_capture_avail(runtime);
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_STARTING:
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_PAUSED:
 		if (avail >= runtime->control->avail_min) {
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -85,6 +85,10 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_PCM1681 if I2C
 	select SND_SOC_PCM1792A if SPI_MASTER
 	select SND_SOC_PCM3008
+	select SND_SOC_PCM3060_I2C if I2C
+	select SND_SOC_PCM3060_SPI if SPI_MASTER
+	select SND_SOC_PCM3168A_I2C if I2C
+	select SND_SOC_PCM3168A_SPI if SPI_MASTER
 	select SND_SOC_PCM512x_I2C if I2C
 	select SND_SOC_PCM512x_SPI if SPI_MASTER
 	select SND_SOC_RT286 if I2C
@@ -506,6 +510,28 @@ config SND_SOC_PCM1792A
 config SND_SOC_PCM3008
        tristate
 
+config SND_SOC_PCM3060
+	tristate
+
+config SND_SOC_PCM3060_SPI
+	tristate
+	select SND_SOC_PCM3060
+
+config SND_SOC_PCM3060_I2C
+	tristate
+	select SND_SOC_PCM3060
+
+config SND_SOC_PCM3168A
+	tristate
+
+config SND_SOC_PCM3168A_SPI
+	tristate
+	select SND_SOC_PCM3168A
+
+config SND_SOC_PCM3168A_I2C
+	tristate
+	select SND_SOC_PCM3168A
+
 config SND_SOC_PCM512x
 	tristate
 
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -78,6 +78,12 @@ snd-soc-nau8825-objs := nau8825.o
 snd-soc-pcm1681-objs := pcm1681.o
 snd-soc-pcm1792a-codec-objs := pcm1792a.o
 snd-soc-pcm3008-objs := pcm3008.o
+snd-soc-pcm3060-objs := pcm3060.o
+snd-soc-pcm3060-i2c-objs := pcm3060-i2c.o
+snd-soc-pcm3060-spi-objs := pcm3060-spi.o
+snd-soc-pcm3168a-objs := pcm3168a.o
+snd-soc-pcm3168a-i2c-objs := pcm3168a-i2c.o
+snd-soc-pcm3168a-spi-objs := pcm3168a-spi.o
 snd-soc-pcm512x-objs := pcm512x.o
 snd-soc-pcm512x-i2c-objs := pcm512x-i2c.o
 snd-soc-pcm512x-spi-objs := pcm512x-spi.o
@@ -273,6 +279,12 @@ obj-$(CONFIG_SND_SOC_NAU8825)   += snd-s
 obj-$(CONFIG_SND_SOC_PCM1681)	+= snd-soc-pcm1681.o
 obj-$(CONFIG_SND_SOC_PCM1792A)	+= snd-soc-pcm1792a-codec.o
 obj-$(CONFIG_SND_SOC_PCM3008)	+= snd-soc-pcm3008.o
+obj-$(CONFIG_SND_SOC_PCM3060)	+= snd-soc-pcm3060.o
+obj-$(CONFIG_SND_SOC_PCM3060_I2C)	+= snd-soc-pcm3060-i2c.o
+obj-$(CONFIG_SND_SOC_PCM3060_SPI)	+= snd-soc-pcm3060-spi.o
+obj-$(CONFIG_SND_SOC_PCM3168A)	+= snd-soc-pcm3168a.o
+obj-$(CONFIG_SND_SOC_PCM3168A_I2C)	+= snd-soc-pcm3168a-i2c.o
+obj-$(CONFIG_SND_SOC_PCM3168A_SPI)	+= snd-soc-pcm3168a-spi.o
 obj-$(CONFIG_SND_SOC_PCM512x)	+= snd-soc-pcm512x.o
 obj-$(CONFIG_SND_SOC_PCM512x_I2C)	+= snd-soc-pcm512x-i2c.o
 obj-$(CONFIG_SND_SOC_PCM512x_SPI)	+= snd-soc-pcm512x-spi.o
--- /dev/null
+++ b/sound/soc/codecs/pcm3060-i2c.c
@@ -0,0 +1,66 @@
+/*
+ * PCM3060 codec i2c driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <sound/soc.h>
+
+#include "pcm3060.h"
+
+static int pcm3060_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	struct regmap *regmap;
+
+	regmap = devm_regmap_init_i2c(i2c, &pcm3060_regmap);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	return pcm3060_probe(&i2c->dev, regmap);
+}
+
+static int pcm3060_i2c_remove(struct i2c_client *i2c)
+{
+	pcm3060_remove(&i2c->dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id pcm3060_i2c_id[] = {
+	{ "pcm3060", },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, pcm3060_i2c_id);
+
+static const struct of_device_id pcm3060_of_match[] = {
+	{ .compatible = "ti,pcm3060", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pcm3060_of_match);
+
+static struct i2c_driver pcm3060_i2c_driver = {
+	.probe		= pcm3060_i2c_probe,
+	.remove		= pcm3060_i2c_remove,
+	.id_table	= pcm3060_i2c_id,
+	.driver		= {
+		.name	= "pcm3060",
+		.of_match_table = pcm3060_of_match,
+		.pm		= &pcm3060_pm_ops,
+	},
+};
+module_i2c_driver(pcm3060_i2c_driver);
+
+MODULE_DESCRIPTION("PCM3060 I2C codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/codecs/pcm3060-spi.c
@@ -0,0 +1,65 @@
+/*
+ * PCM3060 codec spi driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+
+#include <sound/soc.h>
+
+#include "pcm3060.h"
+
+static int pcm3060_spi_probe(struct spi_device *spi)
+{
+	struct regmap *regmap;
+
+	regmap = devm_regmap_init_spi(spi, &pcm3060_regmap);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	return pcm3060_probe(&spi->dev, regmap);
+}
+
+static int pcm3060_spi_remove(struct spi_device *spi)
+{
+	pcm3060_remove(&spi->dev);
+
+	return 0;
+}
+
+static const struct spi_device_id pcm3060_spi_id[] = {
+	{ "pcm3060", },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, pcm3060_spi_id);
+
+static const struct of_device_id pcm3060_of_match[] = {
+	{ .compatible = "ti,pcm3060", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pcm3060_of_match);
+
+static struct spi_driver pcm3060_spi_driver = {
+	.probe		= pcm3060_spi_probe,
+	.remove		= pcm3060_spi_remove,
+	.id_table	= pcm3060_spi_id,
+	.driver = {
+		.name	= "pcm3060",
+		.of_match_table = pcm3060_of_match,
+		.pm		= &pcm3060_pm_ops,
+	},
+};
+module_spi_driver(pcm3060_spi_driver);
+
+MODULE_DESCRIPTION("PCM3060 SPI codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/codecs/pcm3060.c
@@ -0,0 +1,636 @@
+/*
+ * PCM3060 codec driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#include "pcm3060.h"
+
+#define PCM3060_FORMATS (SNDRV_PCM_FMTBIT_S24_3LE | \
+			 SNDRV_PCM_FMTBIT_S24_LE |  \
+			 SNDRV_PCM_FMTBIT_S32_LE)
+
+#define PCM3060_FMT_I2S		0x0
+#define PCM3060_FMT_LEFT_J	0x1
+#define PCM3060_FMT_RIGHT_J	0x2
+
+#define PCM3060_NUM_SUPPLIES 2
+static const char *const pcm3060_supply_names[PCM3060_NUM_SUPPLIES] = {
+	"VCC",
+	"VDD"
+};
+
+struct pcm3060_priv {
+	struct regulator_bulk_data supplies[PCM3060_NUM_SUPPLIES];
+	struct regmap *regmap;
+	struct clk *scki_dac;
+	struct clk *scki_adc;
+	bool adc_slave_mode;
+	bool dac_slave_mode;
+	unsigned long sysclk_dac;
+	unsigned long sysclk_adc;
+	unsigned int adc_fmt;
+	unsigned int dac_fmt;
+};
+
+static const char *const pcm3060_over_mult[] = { "1", "2" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3060_dac_over_mult, PCM3060_DAC_OV_PH_MUTE,
+		PCM3060_DAC_OVER_SHIFT, pcm3060_over_mult);
+
+static const char *const pcm3060_roll_off[] = { "Sharp", "Slow" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3060_dac_roll_off, PCM3060_DAC_FLT_DEMP_Z,
+		PCM3060_DAC_FLT_SHIFT, pcm3060_roll_off);
+
+static const char *const pcm3060_demp[] = { "44.1khz", "48khz", "32khz" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3060_dac_demp, PCM3060_DAC_FLT_DEMP_Z,
+		PCM3060_DAC_DMF_SHIFT, pcm3060_demp);
+
+static const char *const pcm3060_zf_func[] = { "Individual", "Joined" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3060_dac_zf_func, PCM3060_DAC_FLT_DEMP_Z,
+		PCM3060_DAC_AZRO_SHIFT, pcm3060_zf_func);
+
+static const char *const pcm3060_pol[] = { "Active High", "Active Low" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3060_dac_zf_pol, PCM3060_DAC_FLT_DEMP_Z,
+		PCM3060_DAC_ZREV_SHIFT, pcm3060_pol);
+
+static const char *const pcm3060_con[] = { "Differential", "Single-Ended" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3060_dac_con, PCM3060_RST_PWR_SE,
+		PCM3060_SE_SHIFT, pcm3060_con);
+
+/* -100db to 0db, register values 0-54 cause mute */
+static const DECLARE_TLV_DB_SCALE(pcm3060_dac_tlv, -10050, 50, 1);
+
+/* -100db to 20db, register values 0-14 cause mute */
+static const DECLARE_TLV_DB_SCALE(pcm3060_adc_tlv, -10050, 50, 1);
+
+static const struct snd_kcontrol_new pcm3060_snd_controls[] = {
+	SOC_ENUM("DAC Connection Type", pcm3060_dac_con),
+	SOC_DOUBLE_R_RANGE_TLV("DAC Playback Volume",
+			PCM3060_DAC_VOL_L, PCM3060_DAC_VOL_R,
+			0, 54, 255, 0, pcm3060_dac_tlv),
+	SOC_ENUM("DAC Oversampling Rate Multiplier", pcm3060_dac_over_mult),
+	SOC_SINGLE("DAC Invert Switch", PCM3060_DAC_OV_PH_MUTE,
+			PCM3060_DAC_DREV_SHIFT, 1, 0),
+	SOC_ENUM("DAC Digital Filter roll-off", pcm3060_dac_roll_off),
+	SOC_SINGLE("DAC De-Emphasis Switch", PCM3060_DAC_FLT_DEMP_Z,
+			PCM3060_DAC_DMC_SHIFT, 1, 0),
+	SOC_ENUM("DAC De-Emphasis Type", pcm3060_dac_demp),
+	SOC_ENUM("DAC Zero Flag Polarity", pcm3060_dac_zf_pol),
+	SOC_ENUM("DAC Zero Flag Function", pcm3060_dac_zf_func),
+	SOC_DOUBLE_R_RANGE_TLV("ADC Capture Volume",
+			PCM3060_ADC_VOL_L, PCM3060_ADC_VOL_R,
+			0, 14, 255, 0, pcm3060_adc_tlv),
+	SOC_SINGLE("ADC Zero-Cross Detection Switch", PCM3060_ADC_OPT,
+			PCM3060_ADC_ZCDD_SHIFT, 1, 1),
+	SOC_SINGLE("ADC High-Pass Filter Switch", PCM3060_ADC_OPT,
+			PCM3060_ADC_BYP_SHIFT, 1, 1),
+	SOC_SINGLE("ADC Invert Switch", PCM3060_ADC_OPT,
+			PCM3060_ADC_DREV_SHIFT, 1, 0),
+	SOC_DOUBLE("ADC Mute Switch", PCM3060_ADC_OPT,
+			PCM3060_ADC_MUTE_L_SHIFT, PCM3060_ADC_MUTE_R_SHIFT,
+			1, 0),
+};
+
+static const struct snd_soc_dapm_widget pcm3060_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("DAC", "Playback", PCM3060_RST_PWR_SE,
+			PCM3060_DAPSV_SHIFT, 1),
+
+	SND_SOC_DAPM_OUTPUT("AOUTL"),
+	SND_SOC_DAPM_OUTPUT("AOUTR"),
+
+	SND_SOC_DAPM_ADC("ADC", "Capture", PCM3060_RST_PWR_SE,
+			PCM3060_ADPSV_SHIFT, 1),
+
+	SND_SOC_DAPM_INPUT("AINL"),
+	SND_SOC_DAPM_INPUT("AINR"),
+};
+
+static const struct snd_soc_dapm_route pcm3060_dapm_routes[] = {
+	/* Playback */
+	{ "AOUTL", NULL, "DAC" },
+	{ "AOUTR", NULL, "DAC" },
+
+	/* Capture */
+	{ "ADC", NULL, "AINL" },
+	{ "ADC", NULL, "AINR" },
+};
+
+static unsigned int pcm3060_scki_ratios[] = {
+	768,
+	512,
+	384,
+	256,
+	192,
+	128
+};
+
+#define PCM3060_NUM_SCKI_RATIOS_DAC	ARRAY_SIZE(pcm3060_scki_ratios)
+#define PCM3060_NUM_SCKI_RATIOS_ADC	(ARRAY_SIZE(pcm3060_scki_ratios) - 2)
+
+#define PCM1368A_MAX_SYSCLK	36864000
+
+static int pcm3060_reset(struct pcm3060_priv *pcm3060)
+{
+	int ret;
+	u32 mask = PCM3060_MRST_MASK | PCM3060_SRST_MASK;
+	unsigned long sysclk = min(pcm3060->sysclk_dac, pcm3060->sysclk_adc);
+
+	ret = regmap_update_bits(pcm3060->regmap, PCM3060_RST_PWR_SE, mask, 0);
+	if (ret)
+		return ret;
+
+	/* Internal reset is de-asserted after 1024 cycles of both SCKIs */
+	msleep(DIV_ROUND_UP(1024 * 1000, sysclk));
+
+	return regmap_update_bits(pcm3060->regmap, PCM3060_RST_PWR_SE,
+				mask, mask);
+}
+
+static int pcm3060_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct pcm3060_priv *pcm3060 = snd_soc_codec_get_drvdata(dai->codec);
+	u32 mask = PCM3060_DAC_MUTE_R_MASK | PCM3060_DAC_MUTE_L_MASK;
+
+	regmap_update_bits(pcm3060->regmap, PCM3060_DAC_OV_PH_MUTE,
+			mask, mute ? mask : 0);
+
+	return 0;
+}
+
+static int pcm3060_set_dai_sysclk_dac(struct snd_soc_dai *dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct pcm3060_priv *pcm3060 = snd_soc_codec_get_drvdata(dai->codec);
+
+	if (freq > PCM1368A_MAX_SYSCLK)
+		return -EINVAL;
+
+	pcm3060->sysclk_dac = freq;
+
+	return 0;
+}
+
+static int pcm3060_set_dai_sysclk_adc(struct snd_soc_dai *dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct pcm3060_priv *pcm3060 = snd_soc_codec_get_drvdata(dai->codec);
+
+	if (freq > PCM1368A_MAX_SYSCLK)
+		return -EINVAL;
+
+	pcm3060->sysclk_adc = freq;
+
+	return 0;
+}
+
+static int pcm3060_set_dai_fmt(struct snd_soc_dai *dai,
+			       unsigned int format, bool dac)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct pcm3060_priv *pcm3060 = snd_soc_codec_get_drvdata(codec);
+	u32 fmt, reg, mask, shift;
+	bool slave_mode;
+
+	switch (format & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_LEFT_J:
+		fmt = PCM3060_FMT_LEFT_J;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		fmt = PCM3060_FMT_I2S;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		fmt = PCM3060_FMT_RIGHT_J;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported dai format\n");
+		return -EINVAL;
+	}
+
+	switch (format & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		slave_mode = true;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		slave_mode = false;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported master/slave mode\n");
+		return -EINVAL;
+	}
+
+	switch (format & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	default:
+		dev_err(codec->dev, "LRCLK/BCLK inversion not supported\n");
+		return -EINVAL;
+	}
+
+	if (dac) {
+		reg = PCM3060_DAC_FMT;
+		mask = PCM3060_DAC_FMT_MASK;
+		shift = PCM3060_DAC_FMT_SHIFT;
+		pcm3060->dac_slave_mode = slave_mode;
+		pcm3060->dac_fmt = fmt;
+	} else {
+		reg = PCM3060_ADC_FMT;
+		mask = PCM3060_ADC_FMT_MASK;
+		shift = PCM3060_ADC_FMT_SHIFT;
+		pcm3060->adc_slave_mode = slave_mode;
+		pcm3060->adc_fmt = fmt;
+	}
+
+	regmap_update_bits(pcm3060->regmap, reg, mask, fmt << shift);
+
+	return 0;
+}
+
+static int pcm3060_set_dai_fmt_dac(struct snd_soc_dai *dai,
+			       unsigned int format)
+{
+	return pcm3060_set_dai_fmt(dai, format, true);
+}
+
+static int pcm3060_set_dai_fmt_adc(struct snd_soc_dai *dai,
+			       unsigned int format)
+{
+	return pcm3060_set_dai_fmt(dai, format, false);
+}
+
+static int pcm3060_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct pcm3060_priv *pcm3060 = snd_soc_codec_get_drvdata(codec);
+	u32 val, mask, shift, reg;
+	bool slave_mode, tx;
+	unsigned int fmt, rate, channels, max_ratio, ratio;
+	int i;
+	snd_pcm_format_t format;
+
+	rate = params_rate(params);
+	format = params_format(params);
+	channels = params_channels(params);
+
+	tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	if (tx) {
+		max_ratio = PCM3060_NUM_SCKI_RATIOS_DAC;
+		reg = PCM3060_DAC_FMT;
+		mask = PCM3060_DAC_MS_MASK;
+		shift = PCM3060_DAC_MS_SHIFT;
+		ratio = pcm3060->sysclk_dac / rate;
+		slave_mode = pcm3060->dac_slave_mode;
+		fmt = pcm3060->dac_fmt;
+	} else {
+		max_ratio = PCM3060_NUM_SCKI_RATIOS_ADC;
+		reg = PCM3060_ADC_FMT;
+		mask = PCM3060_ADC_MS_MASK;
+		shift = PCM3060_ADC_MS_SHIFT;
+		ratio = pcm3060->sysclk_adc / rate;
+		slave_mode = pcm3060->adc_slave_mode;
+		fmt = pcm3060->adc_fmt;
+	}
+
+	for (i = 0; i < max_ratio; i++) {
+		if (pcm3060_scki_ratios[i] == ratio)
+			break;
+	}
+
+	if (i == max_ratio) {
+		dev_err(codec->dev, "unsupported sysclk ratio\n");
+		return -EINVAL;
+	}
+
+	if (!slave_mode && (format == SNDRV_PCM_FORMAT_S24_3LE)) {
+		dev_err(codec->dev,
+			"48-bit frames not supported in master mode\n");
+		return -EINVAL;
+	}
+
+	val = slave_mode ? 0 : ((i + 1) << shift);
+
+	regmap_update_bits(pcm3060->regmap, reg, mask, val);
+
+	if (tx) {
+		mask = PCM3060_DAC_FMT_MASK;
+		shift = PCM3060_DAC_FMT_SHIFT;
+	} else {
+		mask = PCM3060_ADC_FMT_MASK;
+		shift = PCM3060_ADC_FMT_SHIFT;
+	}
+
+	if ((fmt == PCM3060_FMT_RIGHT_J) && (format == SNDRV_PCM_FORMAT_S32)) {
+		/*
+		 * Justification has no effect here as the whole frame
+		 * is filled with the samples, but the register field
+		 * must be set to left justified for correct operation
+		 */
+		fmt = PCM3060_FMT_LEFT_J;
+	}
+
+	regmap_update_bits(pcm3060->regmap, reg, mask, fmt << shift);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops pcm3060_dac_dai_ops = {
+	.set_fmt	= pcm3060_set_dai_fmt_dac,
+	.set_sysclk	= pcm3060_set_dai_sysclk_dac,
+	.hw_params	= pcm3060_hw_params,
+	.digital_mute	= pcm3060_digital_mute,
+};
+
+static const struct snd_soc_dai_ops pcm3060_adc_dai_ops = {
+	.set_fmt	= pcm3060_set_dai_fmt_adc,
+	.set_sysclk	= pcm3060_set_dai_sysclk_adc,
+	.hw_params	= pcm3060_hw_params,
+};
+
+static struct snd_soc_dai_driver pcm3060_dais[] = {
+	{
+		.name = "pcm3060-dac",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = PCM3060_FORMATS,
+		},
+		.ops = &pcm3060_dac_dai_ops,
+	},
+	{
+		.name = "pcm3060-adc",
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_96000,
+			.formats = PCM3060_FORMATS,
+		},
+		.ops = &pcm3060_adc_dai_ops,
+	},
+};
+
+static const struct reg_default pcm3060_reg_default[] = {
+	{ PCM3060_RST_PWR_SE, PCM3060_MRST_MASK | PCM3060_SRST_MASK |
+			PCM3060_ADPSV_MASK | PCM3060_DAPSV_MASK },
+	{ PCM3060_DAC_VOL_L, 0xff },
+	{ PCM3060_DAC_VOL_R, 0xff },
+	{ PCM3060_DAC_FMT, 0x00 },
+	{ PCM3060_DAC_OV_PH_MUTE, 0x00 },
+	{ PCM3060_DAC_FLT_DEMP_Z, 0x00 },
+	{ PCM3060_ADC_VOL_L, 0xd7 },
+	{ PCM3060_ADC_VOL_R, 0xd7 },
+	{ PCM3060_ADC_FMT, 0x00 },
+	{ PCM3060_ADC_OPT, 0x00 },
+};
+
+static bool pcm3060_volatile_register(struct device *dev, unsigned int reg)
+{
+	return false;
+}
+
+static bool pcm3060_readable_register(struct device *dev, unsigned int reg)
+{
+	if (reg >= PCM3060_RST_PWR_SE)
+		return true;
+	else
+		return false;
+}
+
+static bool pcm3060_writeable_register(struct device *dev, unsigned int reg)
+{
+	if (reg >= PCM3060_RST_PWR_SE)
+		return true;
+	else
+		return false;
+}
+
+const struct regmap_config pcm3060_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = PCM3060_ADC_OPT,
+	.reg_defaults = pcm3060_reg_default,
+	.num_reg_defaults = ARRAY_SIZE(pcm3060_reg_default),
+	.readable_reg = pcm3060_readable_register,
+	.volatile_reg = pcm3060_volatile_register,
+	.writeable_reg = pcm3060_writeable_register,
+	.cache_type = REGCACHE_FLAT,
+};
+EXPORT_SYMBOL_GPL(pcm3060_regmap);
+
+static const struct snd_soc_codec_driver pcm3060_driver = {
+	.controls = pcm3060_snd_controls,
+	.num_controls = ARRAY_SIZE(pcm3060_snd_controls),
+	.dapm_widgets = pcm3060_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(pcm3060_dapm_widgets),
+	.dapm_routes = pcm3060_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(pcm3060_dapm_routes),
+};
+
+int pcm3060_probe(struct device *dev, struct regmap *regmap)
+{
+	struct pcm3060_priv *pcm3060;
+	int ret, i;
+
+	pcm3060 = devm_kzalloc(dev, sizeof(*pcm3060), GFP_KERNEL);
+	if (pcm3060 == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, pcm3060);
+
+	pcm3060->scki_dac = devm_clk_get(dev, "sckid");
+	if (IS_ERR(pcm3060->scki_dac)) {
+		dev_err(dev, "failed to get the clock (dac): %ld\n",
+				PTR_ERR(pcm3060->scki_dac));
+		return PTR_ERR(pcm3060->scki_dac);
+	}
+
+	ret = clk_prepare_enable(pcm3060->scki_dac);
+	if (ret) {
+		dev_err(dev, "failed to enable mclk (dac): %d\n", ret);
+		return ret;
+	}
+
+	pcm3060->sysclk_dac = clk_get_rate(pcm3060->scki_dac);
+
+	pcm3060->scki_adc = devm_clk_get(dev, "sckia");
+	if (IS_ERR(pcm3060->scki_adc)) {
+		dev_err(dev, "failed to get the clock (adc): %ld\n",
+				PTR_ERR(pcm3060->scki_adc));
+		ret = PTR_ERR(pcm3060->scki_adc);
+		goto err_clk;
+	}
+
+	ret = clk_prepare_enable(pcm3060->scki_adc);
+	if (ret) {
+		dev_err(dev, "failed to enable mclk (adc): %d\n", ret);
+		goto err_clk;
+	}
+
+	pcm3060->sysclk_adc = clk_get_rate(pcm3060->scki_adc);
+
+	for (i = 0; i < ARRAY_SIZE(pcm3060->supplies); i++)
+		pcm3060->supplies[i].supply = pcm3060_supply_names[i];
+
+	ret = devm_regulator_bulk_get(dev,
+			ARRAY_SIZE(pcm3060->supplies), pcm3060->supplies);
+	if (ret) {
+		dev_err(dev, "failed to request supplies: %d\n", ret);
+		goto err_clks;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(pcm3060->supplies),
+				    pcm3060->supplies);
+	if (ret) {
+		dev_err(dev, "failed to enable supplies: %d\n", ret);
+		goto err_clks;
+	}
+
+	pcm3060->regmap = regmap;
+	if (IS_ERR(pcm3060->regmap)) {
+		ret = PTR_ERR(pcm3060->regmap);
+		dev_err(dev, "failed to allocate regmap: %d\n", ret);
+		goto err_regulator;
+	}
+
+	ret = pcm3060_reset(pcm3060);
+	if (ret) {
+		dev_err(dev, "Failed to reset device: %d\n", ret);
+		goto err_regulator;
+	}
+
+	ret = snd_soc_register_codec(dev, &pcm3060_driver, pcm3060_dais,
+			ARRAY_SIZE(pcm3060_dais));
+	if (ret) {
+		dev_err(dev, "failed to register codec:%d\n", ret);
+		goto err_regulator;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+
+err_regulator:
+	regulator_bulk_disable(ARRAY_SIZE(pcm3060->supplies),
+			pcm3060->supplies);
+err_clks:
+	clk_disable_unprepare(pcm3060->scki_adc);
+err_clk:
+	clk_disable_unprepare(pcm3060->scki_dac);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pcm3060_probe);
+
+void pcm3060_remove(struct device *dev)
+{
+	snd_soc_unregister_codec(dev);
+	pm_runtime_disable(dev);
+}
+EXPORT_SYMBOL_GPL(pcm3060_remove);
+
+#ifdef CONFIG_PM
+static int pcm3060_rt_resume(struct device *dev)
+{
+	struct pcm3060_priv *pcm3060 = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(pcm3060->scki_dac);
+	if (ret) {
+		dev_err(dev, "failed to enable mclk (dac): %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(pcm3060->scki_adc);
+	if (ret) {
+		dev_err(dev, "failed to enable mclk (adc): %d\n", ret);
+		goto err_clk;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(pcm3060->supplies),
+				    pcm3060->supplies);
+	if (ret) {
+		dev_err(dev, "failed to enable supplies: %d\n", ret);
+		goto err_clks;
+	}
+
+	ret = pcm3060_reset(pcm3060);
+	if (ret) {
+		dev_err(dev, "Failed to reset device: %d\n", ret);
+		goto err_regulator;
+	}
+
+	regcache_cache_only(pcm3060->regmap, false);
+
+	regcache_mark_dirty(pcm3060->regmap);
+
+	ret = regcache_sync(pcm3060->regmap);
+	if (ret) {
+		dev_err(dev, "failed to sync regmap: %d\n", ret);
+		goto err_regulator;
+	}
+
+	return 0;
+
+err_regulator:
+	regulator_bulk_disable(ARRAY_SIZE(pcm3060->supplies),
+			       pcm3060->supplies);
+err_clks:
+	clk_disable_unprepare(pcm3060->scki_adc);
+err_clk:
+	clk_disable_unprepare(pcm3060->scki_dac);
+
+	return ret;
+}
+
+static int pcm3060_rt_suspend(struct device *dev)
+{
+	struct pcm3060_priv *pcm3060 = dev_get_drvdata(dev);
+
+	regcache_cache_only(pcm3060->regmap, true);
+
+	regulator_bulk_disable(ARRAY_SIZE(pcm3060->supplies),
+			       pcm3060->supplies);
+
+	clk_disable_unprepare(pcm3060->scki_adc);
+	clk_disable_unprepare(pcm3060->scki_dac);
+
+	return 0;
+}
+#endif
+
+const struct dev_pm_ops pcm3060_pm_ops = {
+	SET_RUNTIME_PM_OPS(pcm3060_rt_suspend, pcm3060_rt_resume, NULL)
+};
+EXPORT_SYMBOL_GPL(pcm3060_pm_ops);
+
+MODULE_DESCRIPTION("PCM3060 codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/codecs/pcm3060.h
@@ -0,0 +1,86 @@
+/*
+ * PCM3060 codec driver header
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#ifndef __PCM3060_H__
+#define __PCM3060_H__
+
+extern const struct dev_pm_ops pcm3060_pm_ops;
+extern const struct regmap_config pcm3060_regmap;
+
+extern int pcm3060_probe(struct device *dev, struct regmap *regmap);
+extern void pcm3060_remove(struct device *dev);
+
+#define PCM3060_RST_PWR_SE			0x40
+#define PCM3060_MRST_MASK			0x80
+#define PCM3060_SRST_MASK			0x40
+#define PCM3060_ADPSV_SHIFT			5
+#define PCM3060_ADPSV_MASK			0x20
+#define PCM3060_DAPSV_SHIFT			4
+#define PCM3060_DAPSV_MASK			0x10
+#define PCM3060_SE_SHIFT			0
+#define PCM3060_SE_MASK				0x01
+
+#define PCM3060_DAC_VOL_L			0x41
+
+#define PCM3060_DAC_VOL_R			0x42
+
+#define PCM3060_DAC_FMT				0x43
+#define PCM3060_DAC_CSEL_MASK			0x80
+#define PCM3060_DAC_MS_SHIFT			4
+#define PCM3060_DAC_MS_MASK			0x70
+#define PCM3060_DAC_FMT_SHIFT			0
+#define PCM3060_DAC_FMT_MASK			0x3
+
+#define PCM3060_DAC_OV_PH_MUTE			0x44
+#define PCM3060_DAC_OVER_SHIFT			6
+#define PCM3060_DAC_OVER_MASK			0x40
+#define PCM3060_DAC_DREV_SHIFT			2
+#define PCM3060_DAC_DREV_MASK			0x4
+#define PCM3060_DAC_MUTE_R_MASK			0x2
+#define PCM3060_DAC_MUTE_L_MASK			0x1
+
+#define PCM3060_DAC_FLT_DEMP_Z			0x45
+#define PCM3060_DAC_FLT_SHIFT			7
+#define PCM3060_DAC_FLT_MASK			0x80
+#define PCM3060_DAC_DMF_SHIFT			5
+#define PCM3060_DAC_DMF_MASK			0x60
+#define PCM3060_DAC_DMC_SHIFT			4
+#define PCM3060_DAC_DMC_MASK			0x10
+#define PCM3060_DAC_ZREV_SHIFT			1
+#define PCM3060_DAC_ZREV_MASK			0x2
+#define PCM3060_DAC_AZRO_SHIFT			0
+#define PCM3060_DAC_AZRO_MASK			0x1
+
+#define PCM3060_ADC_VOL_L			0x46
+
+#define PCM3060_ADC_VOL_R			0x47
+
+#define PCM3060_ADC_FMT				0x48
+#define PCM3060_ADC_CSEL_MASK			0x80
+#define PCM3060_ADC_MS_SHIFT			4
+#define PCM3060_ADC_MS_MASK			0x70
+#define PCM3060_ADC_FMT_SHIFT			0
+#define PCM3060_ADC_FMT_MASK			0x3
+
+#define PCM3060_ADC_OPT				0x49
+#define PCM3060_ADC_ZCDD_SHIFT			4
+#define PCM3060_ADC_ZCDD_MASK			0x10
+#define PCM3060_ADC_BYP_SHIFT			3
+#define PCM3060_ADC_BYP_MASK			0x8
+#define PCM3060_ADC_DREV_SHIFT			2
+#define PCM3060_ADC_DREV_MASK			0x4
+#define PCM3060_ADC_MUTE_R_SHIFT		1
+#define PCM3060_ADC_MUTE_R_MASK			0x2
+#define PCM3060_ADC_MUTE_L_SHIFT		0
+#define PCM3060_ADC_MUTE_L_MASK			0x1
+
+#endif
--- /dev/null
+++ b/sound/soc/codecs/pcm3168a-i2c.c
@@ -0,0 +1,66 @@
+/*
+ * PCM3168A codec i2c driver
+ *
+ * Copyright (C) 2014 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <sound/soc.h>
+
+#include "pcm3168a.h"
+
+static int pcm3168a_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	struct regmap *regmap;
+
+	regmap = devm_regmap_init_i2c(i2c, &pcm3168a_regmap);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	return pcm3168a_probe(&i2c->dev, regmap);
+}
+
+static int pcm3168a_i2c_remove(struct i2c_client *i2c)
+{
+	pcm3168a_remove(&i2c->dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id pcm3168a_i2c_id[] = {
+	{ "pcm3168a", },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, pcm3168a_i2c_id);
+
+static const struct of_device_id pcm3168a_of_match[] = {
+	{ .compatible = "ti,pcm3168a", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pcm3168a_of_match);
+
+static struct i2c_driver pcm3168a_i2c_driver = {
+	.probe		= pcm3168a_i2c_probe,
+	.remove		= pcm3168a_i2c_remove,
+	.id_table	= pcm3168a_i2c_id,
+	.driver		= {
+		.name	= "pcm3168a",
+		.of_match_table = pcm3168a_of_match,
+		.pm		= &pcm3168a_pm_ops,
+	},
+};
+module_i2c_driver(pcm3168a_i2c_driver);
+
+MODULE_DESCRIPTION("PCM3168A I2C codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/codecs/pcm3168a-spi.c
@@ -0,0 +1,65 @@
+/*
+ * PCM3168A codec spi driver
+ *
+ * Copyright (C) 2014 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+
+#include <sound/soc.h>
+
+#include "pcm3168a.h"
+
+static int pcm3168a_spi_probe(struct spi_device *spi)
+{
+	struct regmap *regmap;
+
+	regmap = devm_regmap_init_spi(spi, &pcm3168a_regmap);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	return pcm3168a_probe(&spi->dev, regmap);
+}
+
+static int pcm3168a_spi_remove(struct spi_device *spi)
+{
+	pcm3168a_remove(&spi->dev);
+
+	return 0;
+}
+
+static const struct spi_device_id pcm3168a_spi_id[] = {
+	{ "pcm3168a", },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, pcm3168a_spi_id);
+
+static const struct of_device_id pcm3168a_of_match[] = {
+	{ .compatible = "ti,pcm3168a", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pcm3168a_of_match);
+
+static struct spi_driver pcm3168a_spi_driver = {
+	.probe		= pcm3168a_spi_probe,
+	.remove		= pcm3168a_spi_remove,
+	.id_table	= pcm3168a_spi_id,
+	.driver = {
+		.name	= "pcm3168a",
+		.of_match_table = pcm3168a_of_match,
+		.pm		= &pcm3168a_pm_ops,
+	},
+};
+module_spi_driver(pcm3168a_spi_driver);
+
+MODULE_DESCRIPTION("PCM3168A SPI codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/codecs/pcm3168a.c
@@ -0,0 +1,764 @@
+/*
+ * PCM3168A codec driver
+ *
+ * Copyright (C) 2014 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#include "pcm3168a.h"
+
+#define PCM3168A_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+			 SNDRV_PCM_FMTBIT_S24_3LE | \
+			 SNDRV_PCM_FMTBIT_S24_LE | \
+			 SNDRV_PCM_FMTBIT_S32_LE)
+
+#define PCM3168A_FMT_I2S		0x0
+#define PCM3168A_FMT_LEFT_J		0x1
+#define PCM3168A_FMT_RIGHT_J		0x2
+#define PCM3168A_FMT_RIGHT_J_16		0x3
+#define PCM3168A_FMT_DSP_A		0x4
+#define PCM3168A_FMT_DSP_B		0x5
+#define PCM3168A_FMT_DSP_MASK		0x4
+
+#define PCM3168A_NUM_SUPPLIES 6
+static const char *const pcm3168a_supply_names[PCM3168A_NUM_SUPPLIES] = {
+	"VDD1",
+	"VDD2",
+	"VCCAD1",
+	"VCCAD2",
+	"VCCDA1",
+	"VCCDA2"
+};
+
+struct pcm3168a_priv {
+	struct regulator_bulk_data supplies[PCM3168A_NUM_SUPPLIES];
+	struct regmap *regmap;
+	struct clk *scki;
+	bool adc_slave_mode;
+	bool dac_slave_mode;
+	unsigned long sysclk;
+	unsigned int adc_fmt;
+	unsigned int dac_fmt;
+};
+
+static const char *const pcm3168a_roll_off[] = { "Sharp", "Slow" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_d1_roll_off, PCM3168A_DAC_OP_FLT,
+		PCM3168A_DAC_FLT_SHIFT, pcm3168a_roll_off);
+static SOC_ENUM_SINGLE_DECL(pcm3168a_d2_roll_off, PCM3168A_DAC_OP_FLT,
+		PCM3168A_DAC_FLT_SHIFT + 1, pcm3168a_roll_off);
+static SOC_ENUM_SINGLE_DECL(pcm3168a_d3_roll_off, PCM3168A_DAC_OP_FLT,
+		PCM3168A_DAC_FLT_SHIFT + 2, pcm3168a_roll_off);
+static SOC_ENUM_SINGLE_DECL(pcm3168a_d4_roll_off, PCM3168A_DAC_OP_FLT,
+		PCM3168A_DAC_FLT_SHIFT + 3, pcm3168a_roll_off);
+
+static const char *const pcm3168a_volume_type[] = {
+		"Individual", "Master + Individual" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_volume_type, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_ATMDDA_SHIFT, pcm3168a_volume_type);
+
+static const char *const pcm3168a_att_speed_mult[] = { "2048", "4096" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_att_mult, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_ATSPDA_SHIFT, pcm3168a_att_speed_mult);
+
+static const char *const pcm3168a_demp[] = {
+		"Disabled", "48khz", "44.1khz", "32khz" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_demp, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_DEMP_SHIFT, pcm3168a_demp);
+
+static const char *const pcm3168a_zf_func[] = {
+		"DAC 1/2/3/4 AND", "DAC 1/2/3/4 OR", "DAC 1/2/3 AND",
+		"DAC 1/2/3 OR", "DAC 4 AND", "DAC 4 OR" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_zf_func, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_AZRO_SHIFT, pcm3168a_zf_func);
+
+static const char *const pcm3168a_pol[] = { "Active High", "Active Low" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_zf_pol, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_ATSPDA_SHIFT, pcm3168a_pol);
+
+static const char *const pcm3168a_con[] = { "Differential", "Single-Ended" };
+
+static SOC_ENUM_DOUBLE_DECL(pcm3168a_adc1_con, PCM3168A_ADC_SEAD,
+				0, 1, pcm3168a_con);
+static SOC_ENUM_DOUBLE_DECL(pcm3168a_adc2_con, PCM3168A_ADC_SEAD,
+				2, 3, pcm3168a_con);
+static SOC_ENUM_DOUBLE_DECL(pcm3168a_adc3_con, PCM3168A_ADC_SEAD,
+				4, 5, pcm3168a_con);
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_adc_volume_type, PCM3168A_ADC_ATT_OVF,
+		PCM3168A_ADC_ATMDAD_SHIFT, pcm3168a_volume_type);
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_adc_att_mult, PCM3168A_ADC_ATT_OVF,
+		PCM3168A_ADC_ATSPAD_SHIFT, pcm3168a_att_speed_mult);
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_adc_ov_pol, PCM3168A_ADC_ATT_OVF,
+		PCM3168A_ADC_OVFP_SHIFT, pcm3168a_pol);
+
+/* -100db to 0db, register values 0-54 cause mute */
+static const DECLARE_TLV_DB_SCALE(pcm3168a_dac_tlv, -10050, 50, 1);
+
+/* -100db to 20db, register values 0-14 cause mute */
+static const DECLARE_TLV_DB_SCALE(pcm3168a_adc_tlv, -10050, 50, 1);
+
+static const struct snd_kcontrol_new pcm3168a_snd_controls[] = {
+	SOC_SINGLE("DAC Power-Save Switch", PCM3168A_DAC_PWR_MST_FMT,
+			PCM3168A_DAC_PSMDA_SHIFT, 1, 1),
+	SOC_ENUM("DAC1 Digital Filter roll-off", pcm3168a_d1_roll_off),
+	SOC_ENUM("DAC2 Digital Filter roll-off", pcm3168a_d2_roll_off),
+	SOC_ENUM("DAC3 Digital Filter roll-off", pcm3168a_d3_roll_off),
+	SOC_ENUM("DAC4 Digital Filter roll-off", pcm3168a_d4_roll_off),
+	SOC_DOUBLE("DAC1 Invert Switch", PCM3168A_DAC_INV, 0, 1, 1, 0),
+	SOC_DOUBLE("DAC2 Invert Switch", PCM3168A_DAC_INV, 2, 3, 1, 0),
+	SOC_DOUBLE("DAC3 Invert Switch", PCM3168A_DAC_INV, 4, 5, 1, 0),
+	SOC_DOUBLE("DAC4 Invert Switch", PCM3168A_DAC_INV, 6, 7, 1, 0),
+	PCM3168A_DOUBLE_STS("DAC1 Zero Flag", PCM3168A_DAC_ZERO, 0, 1, 1, 0),
+	PCM3168A_DOUBLE_STS("DAC2 Zero Flag", PCM3168A_DAC_ZERO, 2, 3, 1, 0),
+	PCM3168A_DOUBLE_STS("DAC3 Zero Flag", PCM3168A_DAC_ZERO, 4, 5, 1, 0),
+	PCM3168A_DOUBLE_STS("DAC4 Zero Flag", PCM3168A_DAC_ZERO, 6, 7, 1, 0),
+	SOC_ENUM("DAC Volume Control Type", pcm3168a_dac_volume_type),
+	SOC_ENUM("DAC Volume Rate Multiplier", pcm3168a_dac_att_mult),
+	SOC_ENUM("DAC De-Emphasis", pcm3168a_dac_demp),
+	SOC_ENUM("DAC Zero Flag Function", pcm3168a_dac_zf_func),
+	SOC_ENUM("DAC Zero Flag Polarity", pcm3168a_dac_zf_pol),
+	SOC_SINGLE_RANGE_TLV("Master Playback Volume",
+			PCM3168A_DAC_VOL_MASTER, 0, 54, 255, 0,
+			pcm3168a_dac_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("DAC1 Playback Volume",
+			PCM3168A_DAC_VOL_CHAN_START,
+			PCM3168A_DAC_VOL_CHAN_START + 1,
+			0, 54, 255, 0, pcm3168a_dac_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("DAC2 Playback Volume",
+			PCM3168A_DAC_VOL_CHAN_START + 2,
+			PCM3168A_DAC_VOL_CHAN_START + 3,
+			0, 54, 255, 0, pcm3168a_dac_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("DAC3 Playback Volume",
+			PCM3168A_DAC_VOL_CHAN_START + 4,
+			PCM3168A_DAC_VOL_CHAN_START + 5,
+			0, 54, 255, 0, pcm3168a_dac_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("DAC4 Playback Volume",
+			PCM3168A_DAC_VOL_CHAN_START + 6,
+			PCM3168A_DAC_VOL_CHAN_START + 7,
+			0, 54, 255, 0, pcm3168a_dac_tlv),
+	SOC_SINGLE("ADC1 High-Pass Filter Switch", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_BYP_SHIFT, 1, 1),
+	SOC_SINGLE("ADC2 High-Pass Filter Switch", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_BYP_SHIFT + 1, 1, 1),
+	SOC_SINGLE("ADC3 High-Pass Filter Switch", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_BYP_SHIFT + 2, 1, 1),
+	SOC_ENUM("ADC1 Connection Type", pcm3168a_adc1_con),
+	SOC_ENUM("ADC2 Connection Type", pcm3168a_adc2_con),
+	SOC_ENUM("ADC3 Connection Type", pcm3168a_adc3_con),
+	SOC_DOUBLE("ADC1 Invert Switch", PCM3168A_ADC_INV, 0, 1, 1, 0),
+	SOC_DOUBLE("ADC2 Invert Switch", PCM3168A_ADC_INV, 2, 3, 1, 0),
+	SOC_DOUBLE("ADC3 Invert Switch", PCM3168A_ADC_INV, 4, 5, 1, 0),
+	SOC_DOUBLE("ADC1 Mute Switch", PCM3168A_ADC_MUTE, 0, 1, 1, 0),
+	SOC_DOUBLE("ADC2 Mute Switch", PCM3168A_ADC_MUTE, 2, 3, 1, 0),
+	SOC_DOUBLE("ADC3 Mute Switch", PCM3168A_ADC_MUTE, 4, 5, 1, 0),
+	PCM3168A_DOUBLE_STS("ADC1 Overflow Flag", PCM3168A_ADC_OV, 0, 1, 1, 0),
+	PCM3168A_DOUBLE_STS("ADC2 Overflow Flag", PCM3168A_ADC_OV, 2, 3, 1, 0),
+	PCM3168A_DOUBLE_STS("ADC3 Overflow Flag", PCM3168A_ADC_OV, 4, 5, 1, 0),
+	SOC_ENUM("ADC Volume Control Type", pcm3168a_adc_volume_type),
+	SOC_ENUM("ADC Volume Rate Multiplier", pcm3168a_adc_att_mult),
+	SOC_ENUM("ADC Overflow Flag Polarity", pcm3168a_adc_ov_pol),
+	SOC_SINGLE_RANGE_TLV("Master Capture Volume",
+			PCM3168A_ADC_VOL_MASTER, 0, 14, 255, 0,
+			pcm3168a_adc_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("ADC1 Capture Volume",
+			PCM3168A_ADC_VOL_CHAN_START,
+			PCM3168A_ADC_VOL_CHAN_START + 1,
+			0, 14, 255, 0, pcm3168a_adc_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("ADC2 Capture Volume",
+			PCM3168A_ADC_VOL_CHAN_START + 2,
+			PCM3168A_ADC_VOL_CHAN_START + 3,
+			0, 14, 255, 0, pcm3168a_adc_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("ADC3 Capture Volume",
+			PCM3168A_ADC_VOL_CHAN_START + 4,
+			PCM3168A_ADC_VOL_CHAN_START + 5,
+			0, 14, 255, 0, pcm3168a_adc_tlv)
+};
+
+static const struct snd_soc_dapm_widget pcm3168a_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("DAC1", "Playback", PCM3168A_DAC_OP_FLT,
+			PCM3168A_DAC_OPEDA_SHIFT, 1),
+	SND_SOC_DAPM_DAC("DAC2", "Playback", PCM3168A_DAC_OP_FLT,
+			PCM3168A_DAC_OPEDA_SHIFT + 1, 1),
+	SND_SOC_DAPM_DAC("DAC3", "Playback", PCM3168A_DAC_OP_FLT,
+			PCM3168A_DAC_OPEDA_SHIFT + 2, 1),
+	SND_SOC_DAPM_DAC("DAC4", "Playback", PCM3168A_DAC_OP_FLT,
+			PCM3168A_DAC_OPEDA_SHIFT + 3, 1),
+
+	SND_SOC_DAPM_OUTPUT("AOUT1L"),
+	SND_SOC_DAPM_OUTPUT("AOUT1R"),
+	SND_SOC_DAPM_OUTPUT("AOUT2L"),
+	SND_SOC_DAPM_OUTPUT("AOUT2R"),
+	SND_SOC_DAPM_OUTPUT("AOUT3L"),
+	SND_SOC_DAPM_OUTPUT("AOUT3R"),
+	SND_SOC_DAPM_OUTPUT("AOUT4L"),
+	SND_SOC_DAPM_OUTPUT("AOUT4R"),
+
+	SND_SOC_DAPM_ADC("ADC1", "Capture", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_PSVAD_SHIFT, 1),
+	SND_SOC_DAPM_ADC("ADC2", "Capture", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_PSVAD_SHIFT + 1, 1),
+	SND_SOC_DAPM_ADC("ADC3", "Capture", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_PSVAD_SHIFT + 2, 1),
+
+	SND_SOC_DAPM_INPUT("AIN1L"),
+	SND_SOC_DAPM_INPUT("AIN1R"),
+	SND_SOC_DAPM_INPUT("AIN2L"),
+	SND_SOC_DAPM_INPUT("AIN2R"),
+	SND_SOC_DAPM_INPUT("AIN3L"),
+	SND_SOC_DAPM_INPUT("AIN3R")
+};
+
+static const struct snd_soc_dapm_route pcm3168a_dapm_routes[] = {
+	/* Playback */
+	{ "AOUT1L", NULL, "DAC1" },
+	{ "AOUT1R", NULL, "DAC1" },
+
+	{ "AOUT2L", NULL, "DAC2" },
+	{ "AOUT2R", NULL, "DAC2" },
+
+	{ "AOUT3L", NULL, "DAC3" },
+	{ "AOUT3R", NULL, "DAC3" },
+
+	{ "AOUT4L", NULL, "DAC4" },
+	{ "AOUT4R", NULL, "DAC4" },
+
+	/* Capture */
+	{ "ADC1", NULL, "AIN1L" },
+	{ "ADC1", NULL, "AIN1R" },
+
+	{ "ADC2", NULL, "AIN2L" },
+	{ "ADC2", NULL, "AIN2R" },
+
+	{ "ADC3", NULL, "AIN3L" },
+	{ "ADC3", NULL, "AIN3R" }
+};
+
+static unsigned int pcm3168a_scki_ratios[] = {
+	768,
+	512,
+	384,
+	256,
+	192,
+	128
+};
+
+#define PCM3168A_NUM_SCKI_RATIOS_DAC	ARRAY_SIZE(pcm3168a_scki_ratios)
+#define PCM3168A_NUM_SCKI_RATIOS_ADC	(ARRAY_SIZE(pcm3168a_scki_ratios) - 2)
+
+#define PCM1368A_MAX_SYSCLK		36864000
+
+static int pcm3168a_reset(struct pcm3168a_priv *pcm3168a)
+{
+	int ret = 0;
+
+	ret = regmap_write(pcm3168a->regmap, PCM3168A_RST_SMODE, 0);
+	if (ret)
+		return ret;
+
+	/* Internal reset is de-asserted after 3846 SCKI cycles */
+	msleep(DIV_ROUND_UP(3846 * 1000, pcm3168a->sysclk));
+
+	return regmap_write(pcm3168a->regmap, PCM3168A_RST_SMODE,
+			PCM3168A_MRST_MASK | PCM3168A_SRST_MASK);
+}
+
+static int pcm3168a_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+
+	regmap_write(pcm3168a->regmap, PCM3168A_DAC_MUTE, mute ? 0xff : 0);
+
+	return 0;
+}
+
+static int pcm3168a_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+
+	if (freq > PCM1368A_MAX_SYSCLK)
+		return -EINVAL;
+
+	pcm3168a->sysclk = freq;
+
+	return 0;
+}
+
+static int pcm3168a_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			       unsigned int format, bool dac)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+	u32 fmt, reg, mask, shift;
+	bool slave_mode;
+
+	if (dac) {
+		reg = PCM3168A_DAC_PWR_MST_FMT;
+		mask = PCM3168A_DAC_FMT_MASK;
+		shift = PCM3168A_DAC_FMT_SHIFT;
+	} else {
+		reg = PCM3168A_ADC_MST_FMT;
+		mask = PCM3168A_ADC_FMTAD_MASK;
+		shift = PCM3168A_ADC_FMTAD_SHIFT;
+	}
+
+	switch (format & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_LEFT_J:
+		fmt = PCM3168A_FMT_LEFT_J;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		fmt = PCM3168A_FMT_I2S;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		fmt = PCM3168A_FMT_RIGHT_J;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		fmt = PCM3168A_FMT_DSP_A;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		fmt = PCM3168A_FMT_DSP_B;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported dai format\n");
+		return -EINVAL;
+	}
+
+	regmap_update_bits(pcm3168a->regmap, reg, mask, fmt << shift);
+
+	switch (format & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		slave_mode = true;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		slave_mode = false;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported master/slave mode\n");
+		return -EINVAL;
+	}
+
+	if (dac) {
+		pcm3168a->dac_slave_mode = slave_mode;
+		pcm3168a->dac_fmt = fmt;
+	} else {
+		pcm3168a->adc_slave_mode = slave_mode;
+		pcm3168a->adc_fmt = fmt;
+	}
+
+	switch (format & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int pcm3168a_set_dai_fmt_dac(struct snd_soc_dai *codec_dai,
+			       unsigned int format)
+{
+	return pcm3168a_set_dai_fmt(codec_dai, format, true);
+}
+
+static int pcm3168a_set_dai_fmt_adc(struct snd_soc_dai *codec_dai,
+			       unsigned int format)
+{
+	return pcm3168a_set_dai_fmt(codec_dai, format, false);
+}
+
+static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+	bool tx, slave_mode;
+	u32 val, mask, shift, reg;
+	unsigned int rate, channels, fmt, ratio, max_ratio;
+	int i;
+	snd_pcm_format_t format;
+
+	rate = params_rate(params);
+	format = params_format(params);
+	channels = params_channels(params);
+
+	ratio = pcm3168a->sysclk / rate;
+
+	tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	if (tx) {
+		max_ratio = PCM3168A_NUM_SCKI_RATIOS_DAC;
+		reg = PCM3168A_DAC_PWR_MST_FMT;
+		mask = PCM3168A_DAC_MSDA_MASK;
+		shift = PCM3168A_DAC_MSDA_SHIFT;
+		slave_mode = pcm3168a->dac_slave_mode;
+		fmt = pcm3168a->dac_fmt;
+	} else {
+		max_ratio = PCM3168A_NUM_SCKI_RATIOS_ADC;
+		reg = PCM3168A_ADC_MST_FMT;
+		mask = PCM3168A_ADC_MSAD_MASK;
+		shift = PCM3168A_ADC_MSAD_SHIFT;
+		slave_mode = pcm3168a->adc_slave_mode;
+		fmt = pcm3168a->adc_fmt;
+	}
+
+	for (i = 0; i < max_ratio; i++) {
+		if (pcm3168a_scki_ratios[i] == ratio)
+			break;
+	}
+
+	if (i == max_ratio) {
+		dev_err(codec->dev, "unsupported sysclk ratio\n");
+		return -EINVAL;
+	}
+
+	if ((!slave_mode || (fmt & PCM3168A_FMT_DSP_MASK)) &&
+			(format == SNDRV_PCM_FORMAT_S24_3LE)) {
+		dev_err(codec->dev, "48-bit frames not supported in master mode or slave mode using DSP(A/B)\n");
+		return -EINVAL;
+	}
+
+	if ((!slave_mode || ((fmt != PCM3168A_FMT_RIGHT_J) &&
+			(fmt != PCM3168A_FMT_LEFT_J))) &&
+			(format == SNDRV_PCM_FORMAT_S16)) {
+		dev_err(codec->dev, "32-bit frames are supported only for slave mode using left/right justified\n");
+		return -EINVAL;
+	}
+
+	val = slave_mode ? 0 : ((i + 1) << shift);
+
+	regmap_update_bits(pcm3168a->regmap, reg, mask, val);
+
+	if (tx) {
+		mask = PCM3168A_DAC_FMT_MASK;
+		shift = PCM3168A_DAC_FMT_SHIFT;
+	} else {
+		mask = PCM3168A_ADC_FMTAD_MASK;
+		shift = PCM3168A_ADC_FMTAD_SHIFT;
+	}
+
+	/*
+	 * Justification has no effect for S32 and S16 as the whole frame
+	 * is filled with the samples, but the register field
+	 * must be set to a particular value for correct operation
+	 */
+	if ((fmt == PCM3168A_FMT_RIGHT_J) &&
+			(format == SNDRV_PCM_FORMAT_S32)) {
+		fmt = PCM3168A_FMT_LEFT_J;
+	} else if (format == SNDRV_PCM_FORMAT_S16) {
+		fmt = PCM3168A_FMT_RIGHT_J_16;
+	}
+
+	regmap_update_bits(pcm3168a->regmap, reg, mask, fmt << shift);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops pcm3168a_dac_dai_ops = {
+	.set_fmt	= pcm3168a_set_dai_fmt_dac,
+	.set_sysclk	= pcm3168a_set_dai_sysclk,
+	.hw_params	= pcm3168a_hw_params,
+	.digital_mute	= pcm3168a_digital_mute
+};
+
+static const struct snd_soc_dai_ops pcm3168a_adc_dai_ops = {
+	.set_fmt	= pcm3168a_set_dai_fmt_adc,
+	.set_sysclk	= pcm3168a_set_dai_sysclk,
+	.hw_params	= pcm3168a_hw_params
+};
+
+static struct snd_soc_dai_driver pcm3168a_dais[] = {
+	{
+		.name = "pcm3168a-dac",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = PCM3168A_FORMATS
+		},
+		.ops = &pcm3168a_dac_dai_ops
+	},
+	{
+		.name = "pcm3168a-adc",
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 6,
+			.rates = SNDRV_PCM_RATE_8000_96000,
+			.formats = PCM3168A_FORMATS
+		},
+		.ops = &pcm3168a_adc_dai_ops
+	},
+};
+
+static const struct reg_default pcm3168a_reg_default[] = {
+	{ PCM3168A_RST_SMODE, PCM3168A_MRST_MASK | PCM3168A_SRST_MASK },
+	{ PCM3168A_DAC_PWR_MST_FMT, 0x00 },
+	{ PCM3168A_DAC_OP_FLT, 0x00 },
+	{ PCM3168A_DAC_INV, 0x00 },
+	{ PCM3168A_DAC_MUTE, 0x00 },
+	{ PCM3168A_DAC_ZERO, 0x00 },
+	{ PCM3168A_DAC_ATT_DEMP_ZF, 0x00 },
+	{ PCM3168A_DAC_VOL_MASTER, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 1, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 2, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 3, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 4, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 5, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 6, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 7, 0xff },
+	{ PCM3168A_ADC_SMODE, 0x00 },
+	{ PCM3168A_ADC_MST_FMT, 0x00 },
+	{ PCM3168A_ADC_PWR_HPFB, 0x00 },
+	{ PCM3168A_ADC_SEAD, 0x00 },
+	{ PCM3168A_ADC_INV, 0x00 },
+	{ PCM3168A_ADC_MUTE, 0x00 },
+	{ PCM3168A_ADC_OV, 0x00 },
+	{ PCM3168A_ADC_ATT_OVF, 0x00 },
+	{ PCM3168A_ADC_VOL_MASTER, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 1, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 2, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 3, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 4, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 5, 0xd3 }
+};
+
+static bool pcm3168a_readable_register(struct device *dev, unsigned int reg)
+{
+	if (reg >= PCM3168A_RST_SMODE)
+		return true;
+	else
+		return false;
+}
+
+static bool pcm3168a_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case PCM3168A_DAC_ZERO:
+	case PCM3168A_ADC_OV:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool pcm3168a_writeable_register(struct device *dev, unsigned int reg)
+{
+	if (reg < PCM3168A_RST_SMODE)
+		return false;
+
+	switch (reg) {
+	case PCM3168A_DAC_ZERO:
+	case PCM3168A_ADC_OV:
+		return false;
+	default:
+		return true;
+	}
+}
+
+const struct regmap_config pcm3168a_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = PCM3168A_ADC_VOL_CHAN_START + 5,
+	.reg_defaults = pcm3168a_reg_default,
+	.num_reg_defaults = ARRAY_SIZE(pcm3168a_reg_default),
+	.readable_reg = pcm3168a_readable_register,
+	.volatile_reg = pcm3168a_volatile_register,
+	.writeable_reg = pcm3168a_writeable_register,
+	.cache_type = REGCACHE_FLAT
+};
+EXPORT_SYMBOL_GPL(pcm3168a_regmap);
+
+static const struct snd_soc_codec_driver pcm3168a_driver = {
+	.controls = pcm3168a_snd_controls,
+	.num_controls = ARRAY_SIZE(pcm3168a_snd_controls),
+	.dapm_widgets = pcm3168a_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(pcm3168a_dapm_widgets),
+	.dapm_routes = pcm3168a_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(pcm3168a_dapm_routes)
+};
+
+int pcm3168a_probe(struct device *dev, struct regmap *regmap)
+{
+	struct pcm3168a_priv *pcm3168a;
+	int ret, i;
+
+	pcm3168a = devm_kzalloc(dev, sizeof(*pcm3168a), GFP_KERNEL);
+	if (pcm3168a == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, pcm3168a);
+
+	pcm3168a->scki = devm_clk_get(dev, "scki");
+	if (IS_ERR(pcm3168a->scki)) {
+		dev_err(dev, "failed to get the clock: %ld\n",
+				PTR_ERR(pcm3168a->scki));
+		return PTR_ERR(pcm3168a->scki);
+	}
+
+	ret = clk_prepare_enable(pcm3168a->scki);
+	if (ret) {
+		dev_err(dev, "failed to enable mclk: %d\n", ret);
+		return ret;
+	}
+
+	pcm3168a->sysclk = clk_get_rate(pcm3168a->scki);
+
+	for (i = 0; i < ARRAY_SIZE(pcm3168a->supplies); i++)
+		pcm3168a->supplies[i].supply = pcm3168a_supply_names[i];
+
+	ret = devm_regulator_bulk_get(dev,
+			ARRAY_SIZE(pcm3168a->supplies), pcm3168a->supplies);
+	if (ret) {
+		dev_err(dev, "failed to request supplies: %d\n", ret);
+		goto err_clk;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(pcm3168a->supplies),
+				    pcm3168a->supplies);
+	if (ret) {
+		dev_err(dev, "failed to enable supplies: %d\n", ret);
+		goto err_clk;
+	}
+
+	pcm3168a->regmap = regmap;
+	if (IS_ERR(pcm3168a->regmap)) {
+		ret = PTR_ERR(pcm3168a->regmap);
+		dev_err(dev, "failed to allocate regmap: %d\n", ret);
+		goto err_regulator;
+	}
+
+	ret = pcm3168a_reset(pcm3168a);
+	if (ret) {
+		dev_err(dev, "Failed to reset device: %d\n", ret);
+		goto err_regulator;
+	}
+
+	ret = snd_soc_register_codec(dev, &pcm3168a_driver, pcm3168a_dais,
+			ARRAY_SIZE(pcm3168a_dais));
+	if (ret) {
+		dev_err(dev, "failed to register codec:%d\n", ret);
+		goto err_regulator;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+
+err_regulator:
+	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
+			pcm3168a->supplies);
+err_clk:
+	clk_disable_unprepare(pcm3168a->scki);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pcm3168a_probe);
+
+void pcm3168a_remove(struct device *dev)
+{
+	snd_soc_unregister_codec(dev);
+	pm_runtime_disable(dev);
+}
+EXPORT_SYMBOL_GPL(pcm3168a_remove);
+
+#ifdef CONFIG_PM
+static int pcm3168a_rt_resume(struct device *dev)
+{
+	struct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(pcm3168a->scki);
+	if (ret) {
+		dev_err(dev, "Failed to enable mclk: %d\n", ret);
+		return ret;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(pcm3168a->supplies),
+				    pcm3168a->supplies);
+	if (ret) {
+		dev_err(dev, "Failed to enable supplies: %d\n", ret);
+		goto err_clk;
+	}
+
+	ret = pcm3168a_reset(pcm3168a);
+	if (ret) {
+		dev_err(dev, "Failed to reset device: %d\n", ret);
+		goto err_regulator;
+	}
+
+	regcache_cache_only(pcm3168a->regmap, false);
+
+	regcache_mark_dirty(pcm3168a->regmap);
+
+	ret = regcache_sync(pcm3168a->regmap);
+	if (ret) {
+		dev_err(dev, "Failed to sync regmap: %d\n", ret);
+		goto err_regulator;
+	}
+
+	return 0;
+
+err_regulator:
+	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
+			       pcm3168a->supplies);
+err_clk:
+	clk_disable_unprepare(pcm3168a->scki);
+
+	return ret;
+}
+
+static int pcm3168a_rt_suspend(struct device *dev)
+{
+	struct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);
+
+	regcache_cache_only(pcm3168a->regmap, true);
+
+	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
+			       pcm3168a->supplies);
+
+	clk_disable_unprepare(pcm3168a->scki);
+
+	return 0;
+}
+#endif
+
+const struct dev_pm_ops pcm3168a_pm_ops = {
+	SET_RUNTIME_PM_OPS(pcm3168a_rt_suspend, pcm3168a_rt_resume, NULL)
+};
+EXPORT_SYMBOL_GPL(pcm3168a_pm_ops);
+
+MODULE_DESCRIPTION("PCM3168A codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/codecs/pcm3168a.h
@@ -0,0 +1,111 @@
+/*
+ * PCM3168A codec driver header
+ *
+ * Copyright (C) 2014 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#ifndef __PCM3168A_H__
+#define __PCM3168A_H__
+
+extern const struct dev_pm_ops pcm3168a_pm_ops;
+extern const struct regmap_config pcm3168a_regmap;
+
+extern int pcm3168a_probe(struct device *dev, struct regmap *regmap);
+extern void pcm3168a_remove(struct device *dev);
+
+#define PCM3168A_RST_SMODE			0x40
+#define PCM3168A_MRST_MASK			0x80
+#define PCM3168A_SRST_MASK			0x40
+#define PCM3168A_DAC_SRDA_SHIFT			0
+#define PCM3168A_DAC_SRDA_MASK			0x3
+
+#define PCM3168A_DAC_PWR_MST_FMT		0x41
+#define PCM3168A_DAC_PSMDA_SHIFT		7
+#define PCM3168A_DAC_PSMDA_MASK			0x80
+#define PCM3168A_DAC_MSDA_SHIFT			4
+#define PCM3168A_DAC_MSDA_MASK			0x70
+#define PCM3168A_DAC_FMT_SHIFT			0
+#define PCM3168A_DAC_FMT_MASK			0xf
+
+#define PCM3168A_DAC_OP_FLT			0x42
+#define PCM3168A_DAC_OPEDA_SHIFT		4
+#define PCM3168A_DAC_OPEDA_MASK			0xf0
+#define PCM3168A_DAC_FLT_SHIFT			0
+#define PCM3168A_DAC_FLT_MASK			0xf
+
+#define PCM3168A_DAC_INV			0x43
+
+#define PCM3168A_DAC_MUTE			0x44
+
+#define PCM3168A_DAC_ZERO			0x45
+
+#define PCM3168A_DAC_ATT_DEMP_ZF		0x46
+#define PCM3168A_DAC_ATMDDA_MASK		0x80
+#define PCM3168A_DAC_ATMDDA_SHIFT		7
+#define PCM3168A_DAC_ATSPDA_MASK		0x40
+#define PCM3168A_DAC_ATSPDA_SHIFT		6
+#define PCM3168A_DAC_DEMP_SHIFT			4
+#define PCM3168A_DAC_DEMP_MASK			0x30
+#define PCM3168A_DAC_AZRO_SHIFT			1
+#define PCM3168A_DAC_AZRO_MASK			0xe
+#define PCM3168A_DAC_ZREV_MASK			0x1
+#define PCM3168A_DAC_ZREV_SHIFT			0
+
+#define PCM3168A_DAC_VOL_MASTER			0x47
+
+#define PCM3168A_DAC_VOL_CHAN_START		0x48
+
+#define PCM3168A_ADC_SMODE			0x50
+#define PCM3168A_ADC_SRAD_SHIFT			0
+#define PCM3168A_ADC_SRAD_MASK			0x3
+
+#define PCM3168A_ADC_MST_FMT			0x51
+#define PCM3168A_ADC_MSAD_SHIFT			4
+#define PCM3168A_ADC_MSAD_MASK			0x70
+#define PCM3168A_ADC_FMTAD_SHIFT		0
+#define PCM3168A_ADC_FMTAD_MASK			0x7
+
+#define PCM3168A_ADC_PWR_HPFB			0x52
+#define PCM3168A_ADC_PSVAD_SHIFT		4
+#define PCM3168A_ADC_PSVAD_MASK			0x70
+#define PCM3168A_ADC_BYP_SHIFT			0
+#define PCM3168A_ADC_BYP_MASK			0x7
+
+#define PCM3168A_ADC_SEAD			0x53
+
+#define PCM3168A_ADC_INV			0x54
+
+#define PCM3168A_ADC_MUTE			0x55
+
+#define PCM3168A_ADC_OV				0x56
+
+#define PCM3168A_ADC_ATT_OVF			0x57
+#define PCM3168A_ADC_ATMDAD_MASK		0x80
+#define PCM3168A_ADC_ATMDAD_SHIFT		7
+#define PCM3168A_ADC_ATSPAD_MASK		0x40
+#define PCM3168A_ADC_ATSPAD_SHIFT		6
+#define PCM3168A_ADC_OVFP_MASK			0x1
+#define PCM3168A_ADC_OVFP_SHIFT			0
+
+#define PCM3168A_ADC_VOL_MASTER			0x58
+
+#define PCM3168A_ADC_VOL_CHAN_START		0x59
+
+#define PCM3168A_DOUBLE_STS(xname, reg, shift_left, shift_right, max, invert) \
+{									\
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),		\
+	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,		\
+	.put = snd_soc_put_volsw,					\
+	.access = SNDRV_CTL_ELEM_ACCESS_READ |				\
+		SNDRV_CTL_ELEM_ACCESS_VOLATILE,				\
+	.private_value = SOC_DOUBLE_VALUE(reg, shift_left, shift_right,	\
+	max, invert, 0)							\
+}
+
+#endif
--- a/sound/soc/img/Kconfig
+++ b/sound/soc/img/Kconfig
@@ -50,3 +50,47 @@ config SND_SOC_IMG_PISTACHIO_INTERNAL_DA
 	help
 	  Say Y or M if you want to add support for Pistachio internal DAC
 	  driver for Imagination Technologies Pistachio internal DAC device.
+
+
+config SND_SOC_IMG_PISTACHIO_EVENT_TIMER
+	tristate "Support for Pistachio SoC Event Timer Driver"
+	depends on SND_SOC_IMG
+	help
+	  Say Y or M if you want to add support for Pistachio event timer
+	  driver for Imagination Technologies Pistachio event timer device.
+
+choice
+	prompt "Pistachio Event Timer Time Units"
+	depends on SND_SOC_IMG_PISTACHIO_EVENT_TIMER
+	default SND_SOC_IMG_PISTACHIO_EVENT_TIMER_ATU if ATU
+	help
+	  Selects the time units used by the Pistachio Event Timer
+
+config SND_SOC_IMG_PISTACHIO_EVENT_TIMER_ATU
+	tristate "Pistachio SoC Event Timer uses ATU units"
+	depends on ATU
+	help
+	  ATU units are used (atu time maintained by ATU driver)
+
+config SND_SOC_IMG_PISTACHIO_EVENT_TIMER_LOCAL
+	tristate "Pistachio SoC Event Timer uses local units"
+	help
+	  Local units are used (nanoseconds since event timer probe)
+
+endchoice
+
+config SND_SOC_IMG_PISTACHIO
+	tristate "Audio support for Pistachio SoC"
+	depends on SND_SOC_IMG
+	select SND_SOC_IMG_I2S_IN
+	select SND_SOC_IMG_I2S_OUT
+	select SND_SOC_IMG_PARALLEL_OUT
+	select SND_SOC_IMG_SPDIF_IN
+	select SND_SOC_IMG_SPDIF_OUT
+	select SND_SOC_IMG_PISTACHIO_EVENT_TIMER
+	select SND_SOC_PCM3168A_I2C
+	select SND_SOC_PCM3168A_SPI
+	select SND_SOC_PCM3060_I2C
+	select SND_SOC_PCM3060_SPI
+	help
+	  Audio support for Imagination Technologies Pistachio Bring-Up Board
--- a/sound/soc/img/Makefile
+++ b/sound/soc/img/Makefile
@@ -5,3 +5,8 @@ obj-$(CONFIG_SND_SOC_IMG_SPDIF_IN) += im
 obj-$(CONFIG_SND_SOC_IMG_SPDIF_OUT) += img-spdif-out.o
 
 obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_INTERNAL_DAC) += pistachio-internal-dac.o
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_EVENT_TIMER) += pistachio-event-timer.o
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_EVENT_TIMER_ATU) += pistachio-event-timer-atu.o
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_EVENT_TIMER_LOCAL) += pistachio-event-timer-local.o
+
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO) += pistachio.o
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer-atu.c
@@ -0,0 +1,68 @@
+/*
+ * Pistachio event timer ATU time units
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timecounter.h>
+
+#include <linux/atu_clk.h>
+
+#include "pistachio-event-timer.h"
+#include "pistachio-event-timer-internal.h"
+
+
+u64 _pistachio_evt_get_time(struct pistachio_evt *evt)
+{
+	return atu_get_current_time();
+}
+EXPORT_SYMBOL_GPL(_pistachio_evt_get_time);
+
+u64 pistachio_evt_get_time(struct pistachio_evt *evt)
+{
+	return atu_get_current_time();
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_time);
+
+int pistachio_evt_time_to_reg(struct pistachio_evt *evt, u64 time, u32 *reg,
+				u64 min_time_delta)
+{
+	return atu_to_frc(time, reg, min_time_delta);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_time_to_reg);
+
+int pistachio_evt_init(struct pistachio_evt *evt)
+{
+	return atu_cyclecounter_register(&evt->cc, evt->audio_pll);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_init);
+
+void pistachio_evt_deinit(struct pistachio_evt *evt)
+{
+	atu_cyclecounter_unregister(&evt->cc);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_deinit);
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer-internal.h
@@ -0,0 +1,70 @@
+/*
+ * Imagination Technologies Pistachio Event Timer Internal Header
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#ifndef __IMG_PISTACHIO_EVT_INTERNAL_H__
+#define __IMG_PISTACHIO_EVT_INTERNAL_H__
+
+enum pistachio_evt_state {
+	PISTACHIO_EVT_STATE_IDLE = 0,
+	PISTACHIO_EVT_STATE_ACTIVE_FIRST,
+	PISTACHIO_EVT_STATE_ACTIVE_SECOND,
+	PISTACHIO_EVT_STATE_ACTIVE_THIRD,
+	PISTACHIO_EVT_STATE_COMPLETE
+};
+
+struct pistachio_evt_callback {
+	u64 trigger_time;
+	u32 cyc;
+	void (*callback)(struct pistachio_evt *, void *);
+	void *context;
+};
+
+struct pistachio_evt_measurement {
+	enum pistachio_evt_state state;
+	void (*callback)(void *);
+	void *context;
+};
+
+struct pistachio_evt {
+	struct list_head list;
+	spinlock_t lock;
+	struct device *dev;
+	struct device_node *np;
+	void __iomem *base;
+	struct clk *audio_pll;
+	struct clk *clk_sys;
+	struct clk *clk_ref_a;
+	struct clk *clk_ref_b;
+	const char *ref_names[2];
+	struct clk *clk_ref_internal;
+	struct cyclecounter cc;
+	struct timecounter tc;
+	struct notifier_block evt_clk_notifier;
+	struct hrtimer poll_timer;
+	ktime_t quarter_rollover;
+	unsigned long sys_rate;
+	struct pistachio_evt_callback trigger_cbs[PISTACHIO_EVT_NUM_ENABLES];
+	struct pistachio_evt_measurement sample_rates[PISTACHIO_EVT_MAX_SOURCES];
+	struct pistachio_evt_measurement phase_difference;
+};
+
+/* Call with lock held */
+u64 _pistachio_evt_get_time(struct pistachio_evt *evt);
+/* Call without lock held */
+u64 pistachio_evt_get_time(struct pistachio_evt *evt);
+int pistachio_evt_time_to_reg(struct pistachio_evt *evt, u64 time,
+				u32 *reg, u64 min_time_delta);
+int pistachio_evt_init(struct pistachio_evt *evt);
+void pistachio_evt_deinit(struct pistachio_evt *evt);
+
+void pistachio_evt_clk_rate_change(struct pistachio_evt *evt);
+#endif
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer-local.c
@@ -0,0 +1,186 @@
+/*
+ * Pistachio event timer local time units
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timecounter.h>
+
+#include <linux/atu_clk.h>
+
+#include "pistachio-event-timer.h"
+#include "pistachio-event-timer-internal.h"
+
+static u64 _pistachio_evt_get_time_cyc(struct pistachio_evt *evt, u32 *cyc)
+{
+	u64 ret;
+
+	ret = timecounter_read(&evt->tc);
+	if (cyc)
+		*cyc = evt->tc.cycle_last;
+
+	return ret;
+}
+
+static u64 pistachio_evt_get_time_cyc(struct pistachio_evt *evt, u32 *cyc)
+{
+	unsigned long flags;
+	u64 ret;
+
+	spin_lock_irqsave(&evt->lock, flags);
+	ret = _pistachio_evt_get_time_cyc(evt, cyc);
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return ret;
+}
+
+u64 _pistachio_evt_get_time(struct pistachio_evt *evt)
+{
+	return _pistachio_evt_get_time_cyc(evt, NULL);
+}
+EXPORT_SYMBOL_GPL(_pistachio_evt_get_time);
+
+u64 pistachio_evt_get_time(struct pistachio_evt *evt)
+{
+	return pistachio_evt_get_time_cyc(evt, NULL);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_time);
+
+int pistachio_evt_time_to_reg(struct pistachio_evt *evt, u64 time, u32 *reg,
+				u64 min_time_delta)
+{
+	u64 tmp;
+	u32 cyc;
+
+	tmp = _pistachio_evt_get_time_cyc(evt, &cyc);
+
+	/* Trigger in the past or too close to current time? */
+	if (time < (tmp + min_time_delta))
+		return -ETIME;
+
+	/*
+	 * Convert ns difference between current time and trigger time
+	 * to event timer cycles
+	 */
+	tmp = (time - tmp) << evt->cc.shift;
+	do_div(tmp, evt->cc.mult);
+
+	/* Trigger too far into the future (cyc value would be ambiguous)? */
+	if (tmp > evt->cc.mask)
+		return -ETIME;
+
+	/* Calculate cycle value for trigger */
+	cyc = (cyc + tmp) & evt->cc.mask;
+
+	/* Final time check before fast write operations */
+	tmp = _pistachio_evt_get_time_cyc(evt, &cyc);
+	if (time < (tmp + min_time_delta))
+		return -ETIME;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_time_to_reg);
+
+static enum hrtimer_restart pistachio_evt_poll(struct hrtimer *tmr)
+{
+	struct pistachio_evt *evt;
+	u64 tmp;
+
+	evt = container_of(tmr, struct pistachio_evt, poll_timer);
+
+	tmp = pistachio_evt_get_time(evt);
+
+	hrtimer_forward(&evt->poll_timer,
+			hrtimer_get_expires(&evt->poll_timer),
+			evt->quarter_rollover);
+
+	return HRTIMER_RESTART;
+}
+
+static void pistachio_evt_start_poll_timer(struct pistachio_evt *evt)
+{
+	ktime_t ks;
+
+	ks = ktime_get();
+	ks = ktime_add(ks, evt->quarter_rollover);
+
+	hrtimer_start(&evt->poll_timer, ks, HRTIMER_MODE_ABS);
+}
+
+static int pistachio_evt_clk_notifier_cb(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	struct pistachio_evt *evt;
+
+	evt = container_of(nb, struct pistachio_evt, evt_clk_notifier);
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		pistachio_evt_get_time_cyc(evt, NULL);
+		return NOTIFY_OK;
+	case POST_RATE_CHANGE:
+		hrtimer_cancel(&evt->poll_timer);
+		pistachio_evt_clk_rate_change(evt);
+		pistachio_evt_get_time_cyc(evt, NULL);
+		pistachio_evt_start_poll_timer(evt);
+		return NOTIFY_OK;
+	case ABORT_RATE_CHANGE:
+		return NOTIFY_OK;
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+int pistachio_evt_init(struct pistachio_evt *evt)
+{
+	int ret;
+
+	timecounter_init(&evt->tc, (const struct cyclecounter *)&evt->cc, 0);
+
+	hrtimer_init(&evt->poll_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+	evt->poll_timer.function = pistachio_evt_poll;
+
+	pistachio_evt_start_poll_timer(evt);
+
+	evt->evt_clk_notifier.notifier_call = pistachio_evt_clk_notifier_cb;
+
+	ret = clk_notifier_register(evt->clk_ref_internal,
+					&evt->evt_clk_notifier);
+
+	if (ret)
+		hrtimer_cancel(&evt->poll_timer);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_init);
+
+void pistachio_evt_deinit(struct pistachio_evt *evt)
+{
+	clk_notifier_unregister(evt->clk_ref_internal, &evt->evt_clk_notifier);
+	hrtimer_cancel(&evt->poll_timer);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_deinit);
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer.c
@@ -0,0 +1,995 @@
+/*
+ * Pistachio event timer driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/hrtimer.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timecounter.h>
+
+#include <linux/mfd/syscon.h>
+
+#include "pistachio-event-timer.h"
+#include "pistachio-event-timer-internal.h"
+
+#define	PISTACHIO_EVT_FIFO_DEPTH		16
+
+#define PISTACHIO_EVT_COUNTER			0x0
+#define PISTACHIO_EVT_COUNTER_MASK		0x3fffffff
+#define PISTACHIO_EVT_COUNTER_ENABLE_MASK	0x80000000
+
+#define PISTACHIO_EVT_TIMESTAMP_STS		0x4
+
+#define PISTACHIO_EVT_TIMESTAMP_CLR		0x8
+
+#define PISTACHIO_EVT_CLKSRC_SELECT		0xc
+#define PISTACHIO_EVT_CLKSRC_SELECT_SHIFT	0
+#define PISTACHIO_EVT_CLKSRC_SELECT_WIDTH	1
+
+#define PISTACHIO_EVT_SOURCE_INTERNAL_START	0x10
+#define PISTACHIO_EVT_SOURCE_INTERNAL_MASK	0xf
+
+#define PISTACHIO_EVT_TIMESTAMP_START		0x40
+#define PISTACHIO_EVT_TIMESTAMP_MASK		PISTACHIO_EVT_COUNTER_MASK
+
+#define PISTACHIO_EVT_TIMER_ENABLE		0x100
+#define PISTACHIO_EVT_TIMER_ENABLE_MASK		0x1
+
+#define PISTACHIO_EVT_SOURCES			0x108
+#define PISTACHIO_EVT_SOURCES_SHIFT		16
+#define	PISTACHIO_EVT_SOURCES_MASK_LSB		0xffffUL
+
+#define PISTACHIO_EVT_PHASE_FIFO		0x110
+
+#define	PISTACHIO_EVT_SAMPLE_FIFO(id)		(0x114 + ((id) * 0x4))
+
+#define PISTACHIO_EVT_EVENT_CTL			0x120
+#define PISTACHIO_EVT_EVENT_CTL_MASK		0x3
+#define PISTACHIO_EVT_EVENT_CTL_WIDTH		2
+
+#define PISTACHIO_EVT_TIME_REG(en)		(0x130 + ((en) * 0x4))
+
+#define PISTACHIO_EVT_INT_STATUS		0x170
+
+#define PISTACHIO_EVT_INT_ENABLE		0x174
+
+#define PISTACHIO_EVT_INT_CLEAR			0x178
+
+#define	PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK	BIT(5)
+#define	PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK	BIT(9)
+#define	PISTACHIO_EVT_INT_PHASE_FNE_MASK	BIT(1)
+
+#define	PISTACHIO_EVT_EXT_SRC_REG		0x158
+#define	PISTACHIO_EVT_EXT_SRC_MASK		0xf
+#define	PISTACHIO_EVT_EXT_SRC_NUM_BANKS		7
+
+#define	PISTACHIO_EVT_MIN_EVENT_DELTA_NS	10000
+
+static LIST_HEAD(pistachio_evt_list);
+static DEFINE_SPINLOCK(pistachio_evt_list_spinlock);
+
+static inline u32 pistachio_evt_readl(struct pistachio_evt *evt, u32 reg)
+{
+	return readl(evt->base + reg);
+}
+
+static inline void pistachio_evt_writel(struct pistachio_evt *evt,
+					u32 val, u32 reg)
+{
+	writel(val, evt->base + reg);
+}
+
+static inline void pistachio_evt_stop_count(struct pistachio_evt *evt)
+{
+	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
+
+	reg &= ~PISTACHIO_EVT_COUNTER_ENABLE_MASK;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_COUNTER);
+}
+
+static inline void pistachio_evt_start_count(struct pistachio_evt *evt)
+{
+	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
+
+	reg |= PISTACHIO_EVT_COUNTER_ENABLE_MASK;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_COUNTER);
+}
+
+static inline u32 pistachio_evt_get_count(struct pistachio_evt *evt)
+{
+	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
+
+	return reg & PISTACHIO_EVT_COUNTER_MASK;
+}
+
+static cycle_t pistachio_evt_cc_read(const struct cyclecounter *cc)
+{
+	struct pistachio_evt *evt;
+
+	evt = container_of(cc, struct pistachio_evt, cc);
+
+	return (cycle_t)pistachio_evt_get_count(evt);
+}
+
+void pistachio_evt_get_time_ts(struct pistachio_evt *evt,
+				struct timespec *ts)
+{
+	u64 tmp;
+
+	tmp = pistachio_evt_get_time(evt);
+	ts->tv_nsec = do_div(tmp, NSEC_PER_SEC);
+	ts->tv_sec = tmp;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_time_ts);
+
+static inline bool pistachio_evt_bad_event(enum pistachio_evt_enable event)
+{
+	switch (event) {
+	case PISTACHIO_EVT_ENABLE_PARALLEL_OUT:
+	case PISTACHIO_EVT_ENABLE_I2S_OUT:
+	case PISTACHIO_EVT_ENABLE_SPDIF_OUT:
+	case PISTACHIO_EVT_ENABLE_EXTERNAL:
+		return false;
+	default:
+		return true;
+	}
+}
+
+static struct pistachio_evt_callback *pistachio_evt_get_next_trigger(
+		struct pistachio_evt *evt, u64 *p_next_trigger)
+{
+	u64 next_trigger, tmp;
+	int i;
+	struct pistachio_evt_callback *cbr = NULL, *cb;
+
+	cb = &evt->trigger_cbs[0];
+	next_trigger = ULLONG_MAX;
+
+	for (i = 0; i < PISTACHIO_EVT_NUM_ENABLES; i++, cb++) {
+		if (!pistachio_evt_bad_event(i)) {
+			tmp = cb->trigger_time;
+			if (tmp && (tmp < next_trigger)) {
+				next_trigger = tmp;
+				cbr = cb;
+			}
+		}
+	}
+
+	*p_next_trigger = next_trigger;
+
+	return cbr;
+}
+
+struct pistachio_evt *pistachio_evt_get(struct device_node *np)
+{
+	struct pistachio_evt *evt, *ret = ERR_PTR(-EPROBE_DEFER);
+
+	spin_lock(&pistachio_evt_list_spinlock);
+	list_for_each_entry(evt, &pistachio_evt_list, list) {
+		if (evt->np == np) {
+			ret = evt;
+			break;
+		}
+	}
+	spin_unlock(&pistachio_evt_list_spinlock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get);
+
+void _pistachio_evt_disable_event(struct pistachio_evt *evt,
+		enum pistachio_evt_enable event)
+{
+	u32 reg;
+
+	dev_dbg(evt->dev, "Disable event %u\n", (unsigned int)event);
+
+	if (pistachio_evt_bad_event(event)) {
+		dev_err(evt->dev, "Disable event %u failed (bad event %u)\n",
+			(unsigned int)event, (unsigned int)event);
+		return;
+	}
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
+
+	reg &= ~(PISTACHIO_EVT_EVENT_CTL_MASK <<
+		(PISTACHIO_EVT_EVENT_CTL_WIDTH * event));
+
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+	evt->trigger_cbs[event].trigger_time = 0;
+}
+EXPORT_SYMBOL_GPL(_pistachio_evt_disable_event);
+
+void pistachio_evt_disable_event(struct pistachio_evt *evt,
+		enum pistachio_evt_enable event)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&evt->lock, flags);
+	_pistachio_evt_disable_event(evt, event);
+	spin_unlock_irqrestore(&evt->lock, flags);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_disable_event);
+
+int pistachio_evt_set_event(struct pistachio_evt *evt,
+		enum pistachio_evt_enable event, enum pistachio_evt_type type,
+		struct timespec *ts,
+		void (*event_trigger_callback)(struct pistachio_evt *, void *),
+		void *context)
+{
+	u32 reg, cyc, event_reg_addr, irq_reg_addr;
+	u64 trigger_time, next_trigger;
+	unsigned long flags;
+	struct pistachio_evt_callback *cb;
+	int ret;
+
+	dev_dbg(evt->dev, "Set event %u type %u time %u,%ld\n",
+		(unsigned int)event, (unsigned int)type,
+		(unsigned int)ts->tv_sec, ts->tv_nsec);
+
+	if (pistachio_evt_bad_event(event)) {
+		dev_err(evt->dev, "Set event %u failed (bad event %u)\n",
+			(unsigned int)event, (unsigned int)event);
+		return -EINVAL;
+	}
+
+	switch (type) {
+	case PISTACHIO_EVT_TYPE_LEVEL:
+	case PISTACHIO_EVT_TYPE_PULSE:
+		break;
+	default:
+		dev_err(evt->dev, "Set event %u failed (bad event type %u)\n",
+			(unsigned int)event, (unsigned int)type);
+		return -EINVAL;
+	}
+
+	if (!ts) {
+		dev_err(evt->dev, "Set event %u failed (ts == NULL)\n",
+			(unsigned int)event);
+		return -EINVAL;
+	}
+
+	event_reg_addr = PISTACHIO_EVT_TIME_REG(event);
+	irq_reg_addr = PISTACHIO_EVT_TIME_REG(PISTACHIO_EVT_ENABLE_IRQ_0);
+
+	trigger_time = (u64)ts->tv_sec * NSEC_PER_SEC + ts->tv_nsec;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	/* Trigger already pending for this event? */
+	if (evt->trigger_cbs[event].trigger_time) {
+		spin_unlock_irqrestore(&evt->lock, flags);
+		dev_err(evt->dev, "Set event %u failed (trigger already pending at %lluns)\n",
+			(unsigned int)event,
+			evt->trigger_cbs[event].trigger_time);
+		return -EINVAL;
+	}
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
+
+	/*
+	 * This event may have triggered previously. The control bits need to
+	 * be cleared before programming a new trigger
+	 */
+	reg &= ~(PISTACHIO_EVT_EVENT_CTL_MASK <<
+		(PISTACHIO_EVT_EVENT_CTL_WIDTH * event));
+
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+	reg |= (type << (PISTACHIO_EVT_EVENT_CTL_WIDTH * event));
+
+	ret = pistachio_evt_time_to_reg(evt, trigger_time, &cyc,
+					PISTACHIO_EVT_MIN_EVENT_DELTA_NS);
+	if (ret) {
+		spin_unlock_irqrestore(&evt->lock, flags);
+		dev_err(evt->dev, "Set event %u failed (%d)\n",
+			(unsigned int)event, ret);
+		return ret;
+	}
+
+	pistachio_evt_writel(evt, cyc, event_reg_addr);
+
+	cb = pistachio_evt_get_next_trigger(evt, &next_trigger);
+
+	/*
+	 * No irq trigger currently set or the new trigger time is
+	 * earlier than the next trigger time?
+	 */
+	if (!cb || (next_trigger > trigger_time)) {
+		pistachio_evt_writel(evt, cyc, irq_reg_addr);
+		reg |= PISTACHIO_EVT_TYPE_LEVEL <<
+			(PISTACHIO_EVT_EVENT_CTL_WIDTH *
+			PISTACHIO_EVT_ENABLE_IRQ_0);
+	}
+
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+	evt->trigger_cbs[event].callback = event_trigger_callback;
+	evt->trigger_cbs[event].trigger_time = trigger_time;
+	evt->trigger_cbs[event].cyc = cyc;
+	evt->trigger_cbs[event].context = context;
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_set_event);
+
+static bool pistachio_evt_retrigger(struct pistachio_evt *evt,
+				struct pistachio_evt_callback *cb)
+{
+	u32 reg, trig_reg_addr;
+	u64 cur_time;
+
+	trig_reg_addr = PISTACHIO_EVT_TIME_REG(PISTACHIO_EVT_ENABLE_IRQ_0);
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
+
+	reg |= (PISTACHIO_EVT_TYPE_LEVEL <<
+		(PISTACHIO_EVT_EVENT_CTL_WIDTH * PISTACHIO_EVT_ENABLE_IRQ_0));
+
+	pistachio_evt_writel(evt, cb->cyc, trig_reg_addr);
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+	cur_time = _pistachio_evt_get_time(evt);
+
+	/* Trigger passed while writing? */
+	if (cb->trigger_time < cur_time)
+		return false;
+
+	return true;
+}
+
+static irqreturn_t pistachio_evt_trigger_0_irq(int irq, void *dev_id)
+{
+	struct pistachio_evt *evt = (struct pistachio_evt *)dev_id;
+	u64 next_trigger, cur_time;
+	struct pistachio_evt_callback *cb;
+	unsigned long flags;
+	u32 reg;
+
+	dev_dbg(evt->dev, "Trigger IRQ\n");
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	while (1) {
+		cb = pistachio_evt_get_next_trigger(evt, &next_trigger);
+
+		/* Disable the irq trigger */
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
+		reg &= ~(PISTACHIO_EVT_EVENT_CTL_MASK <<
+			(PISTACHIO_EVT_EVENT_CTL_WIDTH *
+			PISTACHIO_EVT_ENABLE_IRQ_0));
+		pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+		if (!cb)
+			break;
+
+		cur_time = _pistachio_evt_get_time(evt);
+
+		if (cur_time >= next_trigger) {
+			if (cb->callback)
+				cb->callback(evt, cb->context);
+			cb->trigger_time = 0;
+		} else if (pistachio_evt_retrigger(evt, cb)) {
+			break;
+		} else {
+			if (cb->callback)
+				cb->callback(evt, cb->context);
+			cb->trigger_time = 0;
+		}
+	}
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+int pistachio_evt_set_source(struct pistachio_evt *evt,
+			int id, enum pistachio_evt_source source)
+{
+	unsigned long flags;
+	u32 reg;
+
+	if ((id >= PISTACHIO_EVT_MAX_SOURCES) ||
+			(source >= PISTACHIO_EVT_NUM_SOURCES))
+		return -EINVAL;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_SOURCES);
+	reg &= ~(PISTACHIO_EVT_SOURCES_MASK_LSB <<
+		(id * PISTACHIO_EVT_SOURCES_SHIFT));
+	reg |= source << (id * PISTACHIO_EVT_SOURCES_SHIFT);
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_SOURCES);
+
+	/*
+	 * Changing one of the sources invalidates the active sample rate
+	 * measurement for the source in question, and the active phase
+	 * difference measurement, so reset these states and mask the
+	 * interrupts
+	 */
+	evt->sample_rates[id].state = PISTACHIO_EVT_STATE_IDLE;
+	evt->phase_difference.state = PISTACHIO_EVT_STATE_IDLE;
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+	if (id == 0)
+		reg &= ~PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK;
+	else
+		reg &= ~PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK;
+	reg &= ~PISTACHIO_EVT_INT_PHASE_FNE_MASK;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_set_source);
+
+int pistachio_evt_get_source(struct pistachio_evt *evt,
+		int id, enum pistachio_evt_source *source)
+{
+	u32 reg;
+
+	if (id >= PISTACHIO_EVT_MAX_SOURCES)
+		return -EINVAL;
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_SOURCES);
+
+	*source = (reg >> (id * PISTACHIO_EVT_SOURCES_SHIFT)) &
+		PISTACHIO_EVT_SOURCES_MASK_LSB;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_source);
+
+static void pistachio_evt_clear_fifo(struct pistachio_evt *evt,
+			u32 fifo_offset, u32 mask, bool enable_int)
+{
+	u32 reg;
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+	if (enable_int)
+		reg |= mask;
+	else
+		reg &= ~mask;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+
+	while (1) {
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		if (!(reg & mask))
+			break;
+		reg = pistachio_evt_readl(evt, fifo_offset);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+	}
+}
+
+static void pistachio_evt_new_sr(struct pistachio_evt *evt, int id, u32 mask)
+{
+	u32 reg;
+	enum pistachio_evt_state new_state;
+	struct pistachio_evt_measurement *sr = &evt->sample_rates[id];
+
+	switch (sr->state) {
+	case PISTACHIO_EVT_STATE_ACTIVE_FIRST:
+		/* First sample rate measurement is always invalid */
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_SAMPLE_FIFO(id));
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		if (reg & mask)
+			new_state = PISTACHIO_EVT_STATE_COMPLETE;
+		else
+			new_state = PISTACHIO_EVT_STATE_ACTIVE_SECOND;
+		break;
+
+	case PISTACHIO_EVT_STATE_ACTIVE_SECOND:
+		new_state = PISTACHIO_EVT_STATE_COMPLETE;
+		break;
+
+	default:
+		dev_err(evt->dev, "pistachio_evt_new_sr bad state (%d)\n",
+			(int)sr->state);
+		return;
+	}
+
+	if (new_state == PISTACHIO_EVT_STATE_COMPLETE) {
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+		reg &= ~mask;
+		pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		if (sr->callback)
+			sr->callback(sr->context);
+	}
+
+	sr->state = new_state;
+}
+
+static void pistachio_evt_new_pd(struct pistachio_evt *evt)
+{
+	u32 reg;
+	enum pistachio_evt_state new_state;
+	u32 mask = PISTACHIO_EVT_INT_PHASE_FNE_MASK;
+	struct pistachio_evt_measurement *pd = &evt->phase_difference;
+
+	switch (pd->state) {
+	case PISTACHIO_EVT_STATE_ACTIVE_FIRST:
+		/* First two phase measurements are always invalid */
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_PHASE_FIFO);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		if (!(reg & mask)) {
+			new_state = PISTACHIO_EVT_STATE_ACTIVE_SECOND;
+			break;
+		}
+		/* Fall through */
+	case PISTACHIO_EVT_STATE_ACTIVE_SECOND:
+		/* First two phase measurements are always invalid */
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_PHASE_FIFO);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		if (reg & mask)
+			new_state = PISTACHIO_EVT_STATE_COMPLETE;
+		else
+			new_state = PISTACHIO_EVT_STATE_ACTIVE_THIRD;
+		break;
+
+	case PISTACHIO_EVT_STATE_ACTIVE_THIRD:
+		new_state = PISTACHIO_EVT_STATE_COMPLETE;
+		break;
+
+	default:
+		dev_err(evt->dev, "pistachio_evt_new_pd bad state (%d)\n",
+			(int)pd->state);
+		return;
+	}
+
+	if (new_state == PISTACHIO_EVT_STATE_COMPLETE) {
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+		reg &= ~mask;
+		pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		if (pd->callback)
+			pd->callback(pd->context);
+	}
+
+	pd->state = new_state;
+}
+
+static irqreturn_t pistachio_evt_general_irq(int irq, void *dev_id)
+{
+	struct pistachio_evt *evt = (struct pistachio_evt *)dev_id;
+	unsigned long flags;
+	u32 mask, i, isr, ier;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	while (1) {
+		isr = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		ier = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+		isr &= ier;
+
+		if (!isr)
+			break;
+
+		for (i = 0; i < PISTACHIO_EVT_MAX_SOURCES; i++) {
+			if (i == 0)
+				mask = PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK;
+			else
+				mask = PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK;
+
+			if (isr & mask)
+				pistachio_evt_new_sr(evt, i, mask);
+		}
+
+		if (isr & PISTACHIO_EVT_INT_PHASE_FNE_MASK)
+			pistachio_evt_new_pd(evt);
+	}
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+int pistachio_evt_get_sample_rate(struct pistachio_evt *evt, int id,
+			u32 *val, u32 *sys_freq,
+			void (*callback)(void *context), void *context)
+{
+	unsigned long flags;
+	u32 mask;
+	int ret;
+
+	if (id >= PISTACHIO_EVT_MAX_SOURCES)
+		return -EINVAL;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	switch (evt->sample_rates[id].state) {
+	case PISTACHIO_EVT_STATE_IDLE:
+		if (id == 0)
+			mask = PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK;
+		else
+			mask = PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK;
+
+		pistachio_evt_clear_fifo(evt, PISTACHIO_EVT_SAMPLE_FIFO(id),
+					mask, true);
+
+		ret = -EBUSY;
+		evt->sample_rates[id].state = PISTACHIO_EVT_STATE_ACTIVE_FIRST;
+		evt->sample_rates[id].callback = callback;
+		evt->sample_rates[id].context = context;
+		break;
+
+	case PISTACHIO_EVT_STATE_COMPLETE:
+		*val = pistachio_evt_readl(evt, PISTACHIO_EVT_SAMPLE_FIFO(id));
+		*sys_freq = evt->sys_rate;
+		evt->sample_rates[id].state = PISTACHIO_EVT_STATE_IDLE;
+		ret = 0;
+		break;
+
+	default:
+		ret = -EBUSY;
+		break;
+	}
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_sample_rate);
+
+extern int pistachio_evt_get_phase_difference(struct pistachio_evt *evt,
+			u32 *val, u32 *sys_freq,
+			void (*callback)(void *context), void *context)
+{
+	unsigned long flags;
+	u32 mask;
+	int ret = 0;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	switch (evt->phase_difference.state) {
+	case PISTACHIO_EVT_STATE_IDLE:
+		mask = PISTACHIO_EVT_INT_PHASE_FNE_MASK;
+
+		pistachio_evt_clear_fifo(evt, PISTACHIO_EVT_PHASE_FIFO,
+						mask, true);
+
+		ret = -EBUSY;
+		evt->phase_difference.state = PISTACHIO_EVT_STATE_ACTIVE_FIRST;
+		evt->phase_difference.callback = callback;
+		evt->phase_difference.context = context;
+		break;
+
+	case PISTACHIO_EVT_STATE_COMPLETE:
+		*val = pistachio_evt_readl(evt, PISTACHIO_EVT_PHASE_FIFO);
+		*sys_freq = evt->sys_rate;
+		evt->phase_difference.state = PISTACHIO_EVT_STATE_IDLE;
+		break;
+
+	default:
+		ret = -EBUSY;
+		break;
+	}
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_phase_difference);
+
+void pistachio_evt_abort_measurements(struct pistachio_evt *evt)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&evt->lock, flags);
+	evt->sample_rates[0].state = PISTACHIO_EVT_STATE_IDLE;
+	evt->sample_rates[1].state = PISTACHIO_EVT_STATE_IDLE;
+	evt->phase_difference.state = PISTACHIO_EVT_STATE_IDLE;
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+	reg &= ~PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK;
+	reg &= ~PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK;
+	reg &= ~PISTACHIO_EVT_INT_PHASE_FNE_MASK;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+	spin_unlock_irqrestore(&evt->lock, flags);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_abort_measurements);
+
+void pistachio_evt_clk_rate_change(struct pistachio_evt *evt)
+{
+	u64 tmp;
+	unsigned long flags;
+	unsigned long rate;
+	ktime_t quarter_rollover;
+	u32 mult, shift, mask;
+
+	dev_dbg(evt->dev, "pistachio_evt_clk_rate_change()\n");
+
+	mask = PISTACHIO_EVT_COUNTER_MASK;
+
+	rate = clk_get_rate(evt->clk_ref_internal);
+
+	tmp = ((u64)mask + 1) * NSEC_PER_SEC;
+	do_div(tmp, rate);
+	tmp >>= 2;
+	quarter_rollover.tv64 = tmp;
+
+	clocks_calc_mult_shift(&mult, &shift, rate,
+			NSEC_PER_SEC, DIV_ROUND_UP(mask, rate));
+
+	spin_lock_irqsave(&evt->lock, flags);
+	evt->quarter_rollover = quarter_rollover;
+	evt->cc.mult = mult;
+	evt->cc.shift = shift;
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	dev_dbg(evt->dev, "rate %ld cc mult %u shift %u\n", rate, evt->cc.mult,
+			evt->cc.shift);
+}
+
+static int pistachio_evt_driver_probe(struct platform_device *pdev)
+{
+	struct pistachio_evt *evt;
+	int ret, irq;
+	struct device_node *np = pdev->dev.of_node;
+	u32 clk_select, rate, ext_src_bank;
+	struct resource iomem;
+	struct device *dev = &pdev->dev;
+	struct regmap *periph_regs;
+
+	evt = devm_kzalloc(&pdev->dev, sizeof(*evt), GFP_KERNEL);
+	if (!evt)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, evt);
+
+	evt->dev = dev;
+	evt->np = np;
+
+	spin_lock_init(&evt->lock);
+
+	ret = of_address_to_resource(np, 0, &iomem);
+	if (ret) {
+		dev_err(dev, "Could not get IO memory\n");
+		return ret;
+	}
+
+	evt->base = devm_ioremap_resource(dev, &iomem);
+	if (IS_ERR(evt->base))
+		return PTR_ERR(evt->base);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "can't get general irq\n");
+		return irq;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, pistachio_evt_general_irq,
+				0, pdev->name, evt);
+	if (ret) {
+		dev_err(&pdev->dev, "can't request irq %d\n", irq);
+		return ret;
+	}
+
+	irq = platform_get_irq(pdev, 3);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "can't get trigger 0 irq\n");
+		return irq;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, pistachio_evt_trigger_0_irq,
+				0, pdev->name, evt);
+	if (ret) {
+		dev_err(&pdev->dev, "can't request irq %d\n", irq);
+		return ret;
+	}
+
+	periph_regs = syscon_regmap_lookup_by_phandle(np, "img,cr-periph");
+	if (IS_ERR(periph_regs))
+		return PTR_ERR(periph_regs);
+
+	if (of_property_read_u32(np, "img,ext-src-bank", &ext_src_bank)) {
+		dev_err(&pdev->dev, "No img,ext-src-bank property\n");
+		return -EINVAL;
+	}
+
+	if (ext_src_bank >= PISTACHIO_EVT_EXT_SRC_NUM_BANKS)
+		return -EINVAL;
+
+	regmap_update_bits(periph_regs, PISTACHIO_EVT_EXT_SRC_REG,
+			PISTACHIO_EVT_EXT_SRC_MASK, ext_src_bank);
+
+	if (of_property_read_u32(np, "img,clk-select", &clk_select)) {
+		dev_err(&pdev->dev, "No img,clk-select property\n");
+		return -EINVAL;
+	}
+
+	if (clk_select > 1)
+		return -EINVAL;
+
+	if (of_property_read_u32(np, "img,clk-rate", &rate))
+		rate = 0;
+
+	evt->audio_pll = devm_clk_get(&pdev->dev, "pll");
+	if (IS_ERR(evt->audio_pll))
+		return PTR_ERR(evt->audio_pll);
+
+	ret = clk_prepare_enable(evt->audio_pll);
+	if (ret)
+		return ret;
+
+	evt->clk_ref_a = devm_clk_get(&pdev->dev, "ref0");
+	if (IS_ERR(evt->clk_ref_a)) {
+		ret = PTR_ERR(evt->audio_pll);
+		goto err_pll;
+	}
+
+	ret = clk_prepare_enable(evt->clk_ref_a);
+	if (ret)
+		goto err_pll;
+
+	evt->clk_ref_b = devm_clk_get(&pdev->dev, "ref1");
+	if (IS_ERR(evt->clk_ref_b)) {
+		ret = PTR_ERR(evt->clk_ref_b);
+		goto err_ref_a;
+	}
+
+	ret = clk_prepare_enable(evt->clk_ref_b);
+	if (ret)
+		goto err_ref_a;
+
+	evt->clk_sys = devm_clk_get(&pdev->dev, "sys");
+	if (IS_ERR(evt->clk_sys)) {
+		ret = PTR_ERR(evt->clk_sys);
+		goto err_ref_b;
+	}
+
+	ret = clk_prepare_enable(evt->clk_sys);
+	if (ret)
+		goto err_ref_b;
+
+	evt->sys_rate = clk_get_rate(evt->clk_sys);
+
+	evt->ref_names[0] = __clk_get_name(evt->clk_ref_a);
+	evt->ref_names[1] = __clk_get_name(evt->clk_ref_b);
+
+	evt->clk_ref_internal = clk_register_mux(NULL, "event_timer_internal",
+		evt->ref_names, 2, CLK_SET_RATE_PARENT |
+		CLK_SET_RATE_NO_REPARENT,
+		evt->base + PISTACHIO_EVT_CLKSRC_SELECT,
+		PISTACHIO_EVT_CLKSRC_SELECT_SHIFT,
+		PISTACHIO_EVT_CLKSRC_SELECT_WIDTH,
+		0, NULL);
+
+	if (IS_ERR(evt->clk_ref_internal)) {
+		ret = PTR_ERR(evt->clk_ref_internal);
+		goto err_sys;
+	}
+
+	ret = of_clk_add_provider(np, of_clk_src_simple_get,
+			evt->clk_ref_internal);
+	if (ret)
+		goto err_mux;
+
+	if (clk_select == 0)
+		ret = clk_set_parent(evt->clk_ref_internal, evt->clk_ref_a);
+	else
+		ret = clk_set_parent(evt->clk_ref_internal, evt->clk_ref_b);
+
+	if (ret)
+		goto err_clkp;
+
+	if (rate) {
+		ret = clk_set_rate(evt->clk_ref_internal, rate);
+		if (ret)
+			goto err_clkp;
+	}
+
+	evt->cc.mask = PISTACHIO_EVT_COUNTER_MASK;
+	evt->cc.read = pistachio_evt_cc_read;
+
+	pistachio_evt_writel(evt, PISTACHIO_EVT_TIMER_ENABLE_MASK,
+			PISTACHIO_EVT_TIMER_ENABLE);
+
+	pistachio_evt_start_count(evt);
+
+	pistachio_evt_clk_rate_change(evt);
+
+	ret = pistachio_evt_init(evt);
+	if (ret)
+		goto err_count;
+
+	spin_lock(&pistachio_evt_list_spinlock);
+	list_add(&evt->list, &pistachio_evt_list);
+	spin_unlock(&pistachio_evt_list_spinlock);
+
+	return 0;
+
+err_count:
+	pistachio_evt_stop_count(evt);
+	pistachio_evt_writel(evt, 0, PISTACHIO_EVT_TIMER_ENABLE);
+err_clkp:
+	of_clk_del_provider(np);
+err_mux:
+	clk_unregister(evt->clk_ref_internal);
+err_sys:
+	clk_disable_unprepare(evt->clk_sys);
+err_ref_b:
+	clk_disable_unprepare(evt->clk_ref_b);
+err_ref_a:
+	clk_disable_unprepare(evt->clk_ref_a);
+err_pll:
+	clk_disable_unprepare(evt->audio_pll);
+
+	return ret;
+}
+
+static const struct of_device_id pistachio_evt_of_match[] = {
+	{ .compatible = "img,pistachio-event-timer" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, pistachio_evt_of_match);
+
+static int pistachio_evt_driver_remove(struct platform_device *pdev)
+{
+	struct pistachio_evt *evt = platform_get_drvdata(pdev);
+
+	spin_lock(&pistachio_evt_list_spinlock);
+	list_del(&evt->list);
+	spin_unlock(&pistachio_evt_list_spinlock);
+	pistachio_evt_deinit(evt);
+	pistachio_evt_stop_count(evt);
+	pistachio_evt_writel(evt, 0, PISTACHIO_EVT_TIMER_ENABLE);
+	of_clk_del_provider(evt->dev->of_node);
+	clk_unregister(evt->clk_ref_internal);
+	clk_disable_unprepare(evt->clk_sys);
+	clk_disable_unprepare(evt->clk_ref_b);
+	clk_disable_unprepare(evt->clk_ref_a);
+	clk_disable_unprepare(evt->audio_pll);
+
+	return 0;
+}
+
+static struct platform_driver pistachio_evt_driver = {
+	.driver = {
+		.name = "pistachio-event-timer",
+		.of_match_table = pistachio_evt_of_match,
+	},
+	.probe = pistachio_evt_driver_probe,
+	.remove = pistachio_evt_driver_remove,
+};
+module_platform_driver(pistachio_evt_driver);
+
+MODULE_DESCRIPTION("Event Timer driver");
+MODULE_AUTHOR("Damien Horsley");
+MODULE_LICENSE("GPL v2");
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer.h
@@ -0,0 +1,82 @@
+/*
+ * Imagination Technologies Pistachio Event Timer Header
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#ifndef __IMG_PISTACHIO_EVT_H__
+#define __IMG_PISTACHIO_EVT_H__
+
+struct pistachio_evt;
+
+enum pistachio_evt_enable {
+	PISTACHIO_EVT_ENABLE_PARALLEL_OUT = 0,
+	PISTACHIO_EVT_ENABLE_I2S_OUT,
+	PISTACHIO_EVT_ENABLE_SPDIF_OUT,
+	PISTACHIO_EVT_ENABLE_IRQ_0,
+	PISTACHIO_EVT_ENABLE_IRQ_1,
+	PISTACHIO_EVT_ENABLE_EXTERNAL,
+	PISTACHIO_EVT_NUM_ENABLES
+};
+
+enum pistachio_evt_type {
+	PISTACHIO_EVT_TYPE_PULSE = 1,
+	PISTACHIO_EVT_TYPE_LEVEL
+};
+
+enum pistachio_evt_source {
+	PISTACHIO_EVT_SOURCE_EXTERNAL = 0,
+	PISTACHIO_EVT_SOURCE_SPDIF_IN,
+	PISTACHIO_EVT_SOURCE_SPDIF_OUT,
+	PISTACHIO_EVT_SOURCE_I2S_IN,
+	PISTACHIO_EVT_SOURCE_I2S_OUT,
+	PISTACHIO_EVT_SOURCE_PARALLEL_OUT,
+	PISTACHIO_EVT_NUM_SOURCES
+};
+
+#define	PISTACHIO_EVT_NUM_TIMESTAMP_MODULES	12
+
+#define	PISTACHIO_EVT_MAX_SOURCES		2
+
+extern struct pistachio_evt *pistachio_evt_get(struct device_node *np);
+
+extern void pistachio_evt_get_time_ts(struct pistachio_evt *evt,
+				struct timespec *ts);
+
+/* Call this outside of an event callback */
+extern void pistachio_evt_disable_event(struct pistachio_evt *evt,
+					enum pistachio_evt_enable event);
+
+/* Call this inside of an event callback */
+extern void _pistachio_evt_disable_event(struct pistachio_evt *evt,
+					enum pistachio_evt_enable event);
+
+extern int pistachio_evt_set_event(struct pistachio_evt *evt,
+	enum pistachio_evt_enable event, enum pistachio_evt_type type,
+	struct timespec *ts,
+	void (*event_trigger_callback)(struct pistachio_evt *, void *),
+	void *context);
+
+extern int pistachio_evt_set_source(struct pistachio_evt *evt, int id,
+				enum pistachio_evt_source source);
+
+extern int pistachio_evt_get_source(struct pistachio_evt *evt,
+			int id, enum pistachio_evt_source *source);
+
+extern int pistachio_evt_get_sample_rate(struct pistachio_evt *evt, int id,
+			u32 *val, u32 *sys_freq,
+			void (*callback)(void *), void *context);
+
+extern int pistachio_evt_get_phase_difference(struct pistachio_evt *evt,
+			u32 *val, u32 *sys_freq,
+			void (*callback)(void *), void *context);
+
+extern void pistachio_evt_abort_measurements(struct pistachio_evt *evt);
+
+#endif
--- /dev/null
+++ b/sound/soc/img/pistachio.c
@@ -0,0 +1,2396 @@
+/*
+ * Pistachio audio card driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+#include <linux/mfd/syscon.h>
+
+#include <sound/jack.h>
+#include <sound/soc.h>
+
+#include <dt-bindings/sound/pistachio-audio.h>
+
+#include "pistachio-event-timer.h"
+
+#define	PISTACHIO_PLL_RATE_A		147456000
+#define	PISTACHIO_PLL_RATE_B		135475200
+#define	PISTACHIO_MAX_DIV		256
+#define	PISTACHIO_MIN_MCLK_FREQ		(135475200 / 256)
+
+#define	PISTACHIO_CLOCK_MASTER_EXT	-1
+#define	PISTACHIO_CLOCK_MASTER_LOOPBACK	-2
+
+#define	PISTACHIO_MAX_I2S_CODECS	12
+
+#define	PISTACHIO_MAX_FS_RATES	20
+
+#define	PISTACHIO_I2S_MCLK_MAX_FREQ	200000000
+#define	PISTACHIO_DAC_MCLK_MAX_FREQ	200000000
+
+#define	PISTACHIO_INTERNAL_DAC_PREFIX	"internal-dac"
+
+#define PISTACHIO_I2S_LOOPBACK_REG		0x88
+#define PISTACHIO_I2S_LOOPBACK_CLK_MASK		0x3
+#define PISTACHIO_I2S_LOOPBACK_CLK_SHIFT	0
+
+#define PISTACHIO_I2S_LOOPBACK_CLK_NONE		0
+#define PISTACHIO_I2S_LOOPBACK_CLK_MFIO		1
+#define PISTACHIO_I2S_LOOPBACK_CLK_LOCAL	2
+
+struct pistachio_start_at {
+	enum pistachio_evt_enable enable;
+	spinlock_t lock;
+	struct snd_pcm_substream *substream;
+	unsigned int dummy_frames;
+};
+
+struct pistachio_output {
+	struct pistachio_start_at start_at;
+	unsigned int active_rate;
+};
+
+struct pistachio_parallel_out {
+	struct pistachio_output output;
+	struct snd_soc_dai_link_component internal_dac;
+};
+
+struct pistachio_mclk {
+	struct clk *mclk;
+	unsigned int cur_rate;
+	unsigned int min_rate;
+	unsigned int max_rate;
+};
+
+struct pistachio_i2s_mclk {
+	struct pistachio_mclk *mclk;
+	unsigned int *fs_rates;
+	unsigned int num_fs_rates;
+};
+
+struct pistachio_codec_i2s {
+	struct pistachio_mclk *mclk;
+	struct snd_soc_dai *dai;
+	unsigned int mclk_index;
+};
+
+struct pistachio_i2s {
+	struct pistachio_i2s_mclk mclk_a;
+	struct pistachio_i2s_mclk mclk_b;
+	struct pistachio_codec_i2s *codecs;
+	struct snd_soc_dai_link_component *components;
+	unsigned int num_codecs;
+};
+
+struct pistachio_i2s_out {
+	struct pistachio_i2s i2s;
+	struct pistachio_output output;
+	struct device *cpu_dev;
+};
+
+struct pistachio_i2s_in {
+	struct pistachio_i2s i2s;
+	unsigned int active_rate;
+	unsigned int fmt;
+	int frame_master;
+	int bitclock_master;
+	struct device *cpu_dev;
+};
+
+struct pistachio_i2s_codec_info_s {
+	const char *prefix;
+	const char *dai_name;
+	struct device_node *np;
+	struct pistachio_mclk *mclk;
+	unsigned int mclk_index;
+};
+
+struct pistachio_i2s_codec_info {
+	unsigned int total_codecs;
+	unsigned int unique_codecs;
+	int bitclock_master_idx;
+	int frame_master_idx;
+	struct pistachio_i2s_codec_info_s codecs[PISTACHIO_MAX_I2S_CODECS];
+};
+
+struct pistachio_i2s_mclk_fs_info {
+	unsigned int fs_rates[PISTACHIO_MAX_FS_RATES];
+	unsigned int num_fs_rates;
+};
+
+struct pistachio_card {
+	struct pistachio_output *spdif_out;
+	struct pistachio_parallel_out *parallel_out;
+	struct pistachio_i2s_out *i2s_out;
+	struct pistachio_i2s_in *i2s_in;
+	bool spdif_in;
+	struct device_node *event_timer_np;
+	struct pistachio_evt *event_timer;
+	struct snd_soc_card card;
+	struct snd_soc_jack hp_jack;
+	struct snd_soc_jack_pin hp_jack_pin;
+	struct snd_soc_jack_gpio hp_jack_gpio;
+	unsigned int mute_gpio;
+	bool mute_gpio_inverted;
+	struct mutex rate_mutex;
+	struct clk *audio_pll;
+	unsigned int audio_pll_rate;
+	struct pistachio_mclk i2s_mclk;
+	struct pistachio_mclk dac_mclk;
+	struct regmap *periph_regs;
+	struct notifier_block i2s_clk_notifier;
+	struct snd_ctl_elem_id *sample_rate_ids[PISTACHIO_EVT_MAX_SOURCES];
+	struct snd_ctl_elem_id *phase_difference_id;
+};
+
+static void pistachio_card_set_mclk_codecs(struct pistachio_i2s *i2s,
+			struct pistachio_mclk *mclk, unsigned int rate)
+{
+	int i;
+	struct pistachio_codec_i2s *codec;
+
+	for (i = 0; i < i2s->num_codecs; i++) {
+		codec = &i2s->codecs[i];
+		if (codec->mclk == mclk) {
+			snd_soc_dai_set_sysclk(codec->dai, codec->mclk_index,
+						rate, SND_SOC_CLOCK_IN);
+		}
+	}
+}
+
+static int pistachio_card_set_mclk(struct pistachio_card *pbc,
+		struct pistachio_mclk *mclk, unsigned int rate)
+{
+	int ret;
+	unsigned int old_rate = mclk->cur_rate;
+
+	if (mclk->cur_rate != rate) {
+		/*
+		 * Set cur_rate before the clk_set_rate call to stop the i2s
+		 * mclk rate change callback rejecting the change
+		 */
+		mclk->cur_rate = rate;
+		ret = clk_set_rate(mclk->mclk, rate);
+		if (ret) {
+			mclk->cur_rate = old_rate;
+			return ret;
+		}
+	}
+
+	if (pbc->i2s_out)
+		pistachio_card_set_mclk_codecs(&pbc->i2s_out->i2s, mclk, rate);
+
+	if (pbc->i2s_in)
+		pistachio_card_set_mclk_codecs(&pbc->i2s_in->i2s, mclk, rate);
+
+	return 0;
+}
+
+static int pistachio_card_set_pll_rate(struct pistachio_card *pbc,
+					unsigned int rate)
+{
+	int ret;
+	unsigned int old_i2s_rate;
+
+	/*
+	 * If any active streams are currently using a clock derived
+	 * from the audio pll, a pll rate change cannot take place
+	 */
+	if ((pbc->spdif_out && pbc->spdif_out->active_rate) ||
+	(pbc->parallel_out && pbc->parallel_out->output.active_rate) ||
+	(pbc->i2s_out && pbc->i2s_out->output.active_rate) ||
+	(pbc->i2s_in && pbc->i2s_in->active_rate &&
+	pbc->i2s_in->i2s.mclk_a.mclk))
+		return -EBUSY;
+
+	/*
+	 * Set cur_rate before the clk_set_rate call to stop the i2s
+	 * mclk rate change callback rejecting the change
+	 */
+	old_i2s_rate = pbc->i2s_mclk.cur_rate;
+	pbc->i2s_mclk.cur_rate = rate / (pbc->audio_pll_rate / old_i2s_rate);
+
+	ret = clk_set_rate(pbc->audio_pll, rate);
+
+	if (ret) {
+		pbc->i2s_mclk.cur_rate = old_i2s_rate;
+	} else {
+		pbc->audio_pll_rate = rate;
+		pbc->dac_mclk.cur_rate = rate / (pbc->audio_pll_rate /
+						 pbc->dac_mclk.cur_rate);
+		pistachio_card_set_mclk(pbc, &pbc->i2s_mclk,
+				pbc->i2s_mclk.cur_rate);
+		pistachio_card_set_mclk(pbc, &pbc->dac_mclk,
+				pbc->dac_mclk.cur_rate);
+	}
+
+	return ret;
+}
+
+static void pistachio_card_rate_err(struct pistachio_card *pbc,
+	struct pistachio_i2s_mclk *mclk_a, struct pistachio_i2s_mclk *mclk_b,
+	unsigned int rate_a, unsigned int rate_b)
+{
+	char *mclk_name, *dir_a, *dir_b;
+
+	if (mclk_a->mclk == &pbc->i2s_mclk)
+		mclk_name = "i2s";
+	else
+		mclk_name = "dac";
+
+	if (pbc->i2s_out && ((mclk_a == &pbc->i2s_out->i2s.mclk_a) ||
+			(mclk_a == &pbc->i2s_out->i2s.mclk_b))) {
+		dir_a = "I2S out";
+		dir_b = "I2S in";
+	} else {
+		dir_a = "I2S in";
+		dir_b = "I2S out";
+	}
+
+	if (!mclk_b) {
+		dev_err(pbc->card.dev,
+			"No valid rate for mclk %s (%s sample rate %u)\n",
+			mclk_name, dir_a, rate_a);
+	} else {
+		dev_err(pbc->card.dev,
+			"No valid rate for mclk %s (%s sample rate %u, %s sample rate %u)\n",
+			mclk_name, dir_a, rate_a, dir_b, rate_b);
+	}
+}
+
+static int pistachio_card_get_optimal_mclk_rate(struct pistachio_card *pbc,
+	struct pistachio_i2s_mclk *mclk_a, struct pistachio_i2s_mclk *mclk_b,
+	unsigned int rate_a, unsigned int rate_b, unsigned int *p_mclk_rate)
+{
+	int i, j;
+	unsigned int div, total_div, mclk_rate;
+
+	/*
+	 * If the current system clock rate has zero difference, do not
+	 * change the rate. This ensures a rate set using the "I2S Rates"
+	 * control will not be erroneously overridden by a hw_params call
+	 */
+	for (i = 0; i < mclk_a->num_fs_rates; i++)
+		if ((mclk_a->mclk->cur_rate / mclk_a->fs_rates[i]) == rate_a)
+			break;
+	if (i != mclk_a->num_fs_rates) {
+		if (mclk_b) {
+			for (i = 0; i < mclk_b->num_fs_rates; i++)
+				if ((mclk_b->mclk->cur_rate /
+						mclk_b->fs_rates[i]) == rate_b)
+					break;
+			if (i != mclk_b->num_fs_rates) {
+				*p_mclk_rate = mclk_a->mclk->cur_rate;
+				return 0;
+			}
+		} else {
+			*p_mclk_rate = mclk_a->mclk->cur_rate;
+			return 0;
+		}
+	}
+
+	total_div = pbc->audio_pll_rate / rate_a;
+
+	for (i = 0; i < mclk_a->num_fs_rates; i++) {
+		div = total_div / mclk_a->fs_rates[i];
+		if (div > PISTACHIO_MAX_DIV)
+			continue;
+		mclk_rate = pbc->audio_pll_rate / div;
+		if ((mclk_rate < mclk_a->mclk->min_rate) ||
+				(mclk_rate > mclk_a->mclk->max_rate))
+			continue;
+		if ((rate_a * mclk_a->fs_rates[i] * div) != pbc->audio_pll_rate)
+			continue;
+
+		if (!mclk_b)
+			break;
+
+		for (j = 0; j < mclk_b->num_fs_rates; j++) {
+			if ((rate_b * mclk_b->fs_rates[j] * div) ==
+					pbc->audio_pll_rate)
+				break;
+		}
+		if (j != mclk_b->num_fs_rates)
+			break;
+	}
+
+	if (i == mclk_a->num_fs_rates) {
+		pistachio_card_rate_err(pbc, mclk_a, mclk_b, rate_a, rate_b);
+		return -EINVAL;
+	}
+
+	*p_mclk_rate = mclk_rate;
+
+	return 0;
+}
+
+static bool pistachio_card_mclk_active(struct pistachio_card *pbc,
+					struct pistachio_mclk *mclk)
+{
+	if (pbc->i2s_out && pbc->i2s_out->output.active_rate) {
+		if (pbc->i2s_out->i2s.mclk_a.mclk == mclk)
+			return true;
+		if (pbc->i2s_out->i2s.mclk_b.mclk == mclk)
+			return true;
+	}
+
+	if (pbc->i2s_in && pbc->i2s_in->active_rate) {
+		if (pbc->i2s_in->i2s.mclk_a.mclk == mclk)
+			return true;
+		if (pbc->i2s_in->i2s.mclk_b.mclk == mclk)
+			return true;
+	}
+
+	return false;
+}
+
+static int pistachio_card_update_mclk(struct pistachio_card *pbc,
+	struct pistachio_i2s_mclk *mclk_a, struct pistachio_i2s_mclk *mclk_b,
+	unsigned int rate_a, unsigned int rate_b)
+{
+	unsigned int mclk_rate;
+	int ret;
+
+	ret = pistachio_card_get_optimal_mclk_rate(pbc, mclk_a, mclk_b, rate_a,
+							rate_b, &mclk_rate);
+	if (ret)
+		return ret;
+
+	if (mclk_a->mclk->cur_rate != mclk_rate) {
+		if (pistachio_card_mclk_active(pbc, mclk_a->mclk))
+			return -EBUSY;
+		return pistachio_card_set_mclk(pbc, mclk_a->mclk, mclk_rate);
+	}
+
+	return 0;
+}
+
+static int pistachio_card_update_mclk_single(struct pistachio_card *pbc,
+		struct pistachio_i2s_mclk *mclk, unsigned int rate)
+{
+	return pistachio_card_update_mclk(pbc, mclk, NULL, rate, 0);
+}
+
+static inline int pistachio_card_get_pll_rate(unsigned int rate)
+{
+	switch (rate) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+	case 192000:
+		return PISTACHIO_PLL_RATE_A;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		return PISTACHIO_PLL_RATE_B;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int _pistachio_card_change_rate(struct pistachio_card *pbc,
+			unsigned int rate, struct pistachio_i2s *i2s)
+{
+	int ret = 0;
+	unsigned int pll_rate;
+
+	ret = pistachio_card_get_pll_rate(rate);
+	if (ret < 0)
+		return ret;
+
+	pll_rate = ret;
+
+	if (pbc->audio_pll_rate != pll_rate) {
+		ret = pistachio_card_set_pll_rate(pbc, pll_rate);
+		if (ret)
+			return ret;
+	}
+
+	/*
+	 * Nothing more to do if an mclk is not used. The individual
+	 * cpu-dai drivers will make the required clock changes
+	 */
+	if (!i2s)
+		return 0;
+
+	ret = pistachio_card_update_mclk_single(pbc, &i2s->mclk_a, rate);
+	if (ret)
+		return ret;
+
+	if (!i2s->mclk_b.mclk)
+		return 0;
+
+	return pistachio_card_update_mclk_single(pbc, &i2s->mclk_b, rate);
+}
+
+static int pistachio_card_change_rate(struct pistachio_card *pbc,
+			unsigned int rate, struct pistachio_i2s *i2s,
+			unsigned int *active_rate)
+{
+	int ret;
+
+	mutex_lock(&pbc->rate_mutex);
+	*active_rate = 0;
+	ret = _pistachio_card_change_rate(pbc, rate, i2s);
+	if (!ret)
+		*active_rate = rate;
+	mutex_unlock(&pbc->rate_mutex);
+
+	return ret;
+}
+
+static void pistachio_card_start_at_cb(struct pistachio_evt *evt,
+					void *context)
+{
+	struct pistachio_start_at *sa = context;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sa->lock, flags);
+
+	if (!sa->substream) {
+		spin_unlock_irqrestore(&sa->lock, flags);
+		return;
+	}
+
+	snd_pcm_start_at_trigger(sa->substream);
+
+	_pistachio_evt_disable_event(evt, sa->enable);
+
+	sa->substream = NULL;
+
+	spin_unlock_irqrestore(&sa->lock, flags);
+}
+
+static int pistachio_card_start_at(struct pistachio_output *output,
+		struct pistachio_evt *evt, struct snd_pcm_substream *st,
+		const struct timespec *ts)
+{
+	int ret;
+	unsigned long flags;
+	struct timespec ts_sub, ts_new;
+	struct pistachio_start_at *sa = &output->start_at;
+	u64 temp;
+
+	/* Adjust start time to account for dummy frames output at start */
+	temp = (u64)NSEC_PER_SEC * sa->dummy_frames;
+	ts_sub.tv_sec = 0;
+	ts_sub.tv_nsec = DIV_ROUND_CLOSEST_ULL(temp, output->active_rate);
+	ts_new = timespec_sub(*ts, ts_sub);
+
+	spin_lock_irqsave(&sa->lock, flags);
+
+	ret = pistachio_evt_set_event(evt, sa->enable,
+		PISTACHIO_EVT_TYPE_LEVEL, &ts_new,
+		pistachio_card_start_at_cb, sa);
+	if (!ret)
+		sa->substream = st;
+
+	spin_unlock_irqrestore(&sa->lock, flags);
+
+	return ret;
+}
+
+static int pistachio_card_start_at_abort(struct pistachio_start_at *sa,
+		struct pistachio_evt *evt, struct snd_pcm_substream *st)
+{
+	unsigned long flags;
+
+	if (spin_trylock_irqsave(&sa->lock, flags)) {
+		if (!sa->substream) {
+			/* Already started */
+			spin_unlock_irqrestore(&sa->lock, flags);
+			return -EINVAL;
+		}
+
+		snd_pcm_start_at_cleanup(st);
+
+		sa->substream = NULL;
+
+		spin_unlock_irqrestore(&sa->lock, flags);
+
+		pistachio_evt_disable_event(evt, sa->enable);
+	} else {
+		/* In the process of being started */
+		spin_unlock_irqrestore(&sa->lock, flags);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int pistachio_card_i2s_link_init(struct pistachio_i2s *i2s,
+					struct snd_soc_pcm_runtime *rtd)
+{
+	int ret, i, id;
+	unsigned long rate;
+	struct pistachio_codec_i2s *codec;
+
+	for (i = 0; i < i2s->num_codecs; i++) {
+		codec = &i2s->codecs[i];
+		codec->dai = rtd->codec_dais[i];
+		if (codec->mclk) {
+			rate = codec->mclk->cur_rate;
+			id = codec->mclk_index;
+			ret = snd_soc_dai_set_sysclk(codec->dai, id, rate, 0);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void pistachio_card_parallel_out_shutdown(struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	pbc->parallel_out->output.active_rate = 0;
+}
+
+static int pistachio_card_parallel_out_hw_params(struct snd_pcm_substream *st,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_change_rate(pbc, params_rate(params), NULL,
+				&pbc->parallel_out->output.active_rate);
+}
+
+static int pistachio_card_parallel_out_start_at(struct snd_pcm_substream *st,
+		int clock_type, const struct timespec *ts)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at(&pbc->parallel_out->output,
+					pbc->event_timer, st, ts);
+}
+
+static int pistachio_card_parallel_out_start_at_abort(
+			struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at_abort(
+					&pbc->parallel_out->output.start_at,
+					pbc->event_timer, st);
+}
+
+static struct snd_soc_ops pistachio_card_parallel_out_ops = {
+	.shutdown = pistachio_card_parallel_out_shutdown,
+	.hw_params = pistachio_card_parallel_out_hw_params,
+	.start_at = pistachio_card_parallel_out_start_at,
+	.start_at_abort = pistachio_card_parallel_out_start_at_abort
+};
+
+static void pistachio_card_spdif_out_shutdown(struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	pbc->spdif_out->active_rate = 0;
+}
+
+static int pistachio_card_spdif_out_hw_params(struct snd_pcm_substream *st,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_change_rate(pbc, params_rate(params), NULL,
+					&pbc->spdif_out->active_rate);
+}
+
+static int pistachio_card_spdif_out_start_at(struct snd_pcm_substream *st,
+		int clock_type, const struct timespec *ts)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at(pbc->spdif_out, pbc->event_timer,
+					st, ts);
+}
+
+static int pistachio_card_spdif_out_start_at_abort(
+		struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at_abort(&pbc->spdif_out->start_at,
+						pbc->event_timer, st);
+}
+
+static struct snd_soc_ops pistachio_card_spdif_out_ops = {
+	.shutdown = pistachio_card_spdif_out_shutdown,
+	.hw_params = pistachio_card_spdif_out_hw_params,
+	.start_at = pistachio_card_spdif_out_start_at,
+	.start_at_abort = pistachio_card_spdif_out_start_at_abort
+};
+
+static int pistachio_card_i2s_clk_cb(struct notifier_block *nb,
+					unsigned long event, void *data)
+{
+	struct clk_notifier_data *ndata = data;
+	struct pistachio_card *pbc;
+	unsigned int diff;
+	u64 cur_rate;
+	u64 tolerance;
+
+	pbc = container_of(nb, struct pistachio_card, i2s_clk_notifier);
+
+	cur_rate = pbc->i2s_mclk.cur_rate;
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		diff = abs(ndata->new_rate - cur_rate);
+		tolerance = DIV_ROUND_CLOSEST_ULL(cur_rate * 5, 100);
+		if (diff < tolerance) {
+			/*
+			 * Fractional adjustment made by atu, or new rate set
+			 * by card driver if diff is zero
+			 */
+			return NOTIFY_OK;
+		} else {
+			/* Significant change made by i2s cpu dai driver */
+			return NOTIFY_STOP;
+		}
+	case POST_RATE_CHANGE:
+	case ABORT_RATE_CHANGE:
+		return NOTIFY_OK;
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+static int pistachio_card_i2s_out_link_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	pbc->i2s_out->cpu_dev = rtd->cpu_dai->dev;
+
+	return pistachio_card_i2s_link_init(&pbc->i2s_out->i2s, rtd);
+}
+
+static void pistachio_card_i2s_out_shutdown(struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	pbc->i2s_out->output.active_rate = 0;
+}
+
+static int pistachio_card_i2s_out_hw_params(struct snd_pcm_substream *st,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_change_rate(pbc, params_rate(params),
+		&pbc->i2s_out->i2s, &pbc->i2s_out->output.active_rate);
+}
+
+static int pistachio_card_i2s_out_start_at(struct snd_pcm_substream *st,
+		int clock_type, const struct timespec *ts)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at(&pbc->i2s_out->output,
+					pbc->event_timer, st, ts);
+}
+
+static int pistachio_card_i2s_out_start_at_abort(
+		struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at_abort(&pbc->i2s_out->output.start_at,
+						pbc->event_timer, st);
+}
+
+static struct snd_soc_ops pistachio_card_i2s_out_ops = {
+	.shutdown = pistachio_card_i2s_out_shutdown,
+	.hw_params = pistachio_card_i2s_out_hw_params,
+	.start_at = pistachio_card_i2s_out_start_at,
+	.start_at_abort = pistachio_card_i2s_out_start_at_abort
+};
+
+static int pistachio_card_i2s_in_link_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret, i;
+	unsigned int fmt;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+	u32 val;
+
+	pbc->i2s_in->cpu_dev = rtd->cpu_dai->dev;
+
+	ret = pistachio_card_i2s_link_init(&pbc->i2s_in->i2s, rtd);
+	if (ret)
+		return ret;
+
+	fmt = pbc->i2s_in->fmt | SND_SOC_DAIFMT_CBM_CFM;
+	ret = snd_soc_dai_set_fmt(rtd->cpu_dai, fmt);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < pbc->i2s_in->i2s.num_codecs; i++) {
+		fmt = pbc->i2s_in->fmt;
+
+		if (i == pbc->i2s_in->frame_master)
+			if (i == pbc->i2s_in->bitclock_master)
+				fmt |= SND_SOC_DAIFMT_CBM_CFM;
+			else
+				fmt |= SND_SOC_DAIFMT_CBS_CFM;
+		else
+			if (i == pbc->i2s_in->bitclock_master)
+				fmt |= SND_SOC_DAIFMT_CBM_CFS;
+			else
+				fmt |= SND_SOC_DAIFMT_CBS_CFS;
+
+		ret = snd_soc_dai_set_fmt(rtd->codec_dais[i], fmt);
+		if (ret)
+			return ret;
+	}
+
+	if (pbc->i2s_in->frame_master == PISTACHIO_CLOCK_MASTER_LOOPBACK)
+		val = PISTACHIO_I2S_LOOPBACK_CLK_LOCAL;
+	else
+		val = PISTACHIO_I2S_LOOPBACK_CLK_NONE;
+
+	regmap_update_bits(pbc->periph_regs, PISTACHIO_I2S_LOOPBACK_REG,
+				PISTACHIO_I2S_LOOPBACK_CLK_MASK, val);
+
+	return 0;
+}
+
+static void pistachio_card_i2s_in_shutdown(struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	pbc->i2s_in->active_rate = 0;
+}
+
+static int pistachio_card_i2s_in_hw_params(struct snd_pcm_substream *st,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_change_rate(pbc, params_rate(params),
+		&pbc->i2s_in->i2s, &pbc->i2s_in->active_rate);
+}
+
+static struct snd_soc_ops pistachio_card_i2s_in_ops = {
+	.shutdown = pistachio_card_i2s_in_shutdown,
+	.hw_params = pistachio_card_i2s_in_hw_params
+};
+
+static int pistachio_card_parse_of_spdif_out(struct device_node *node,
+		struct pistachio_card *pbc, struct snd_soc_dai_link *link)
+{
+	struct device_node *np;
+
+	pbc->spdif_out = devm_kzalloc(pbc->card.dev, sizeof(*pbc->spdif_out),
+					GFP_KERNEL);
+	if (!pbc->spdif_out)
+		return -ENOMEM;
+
+	pbc->spdif_out->start_at.enable = PISTACHIO_EVT_ENABLE_SPDIF_OUT;
+	pbc->spdif_out->start_at.dummy_frames = 1;
+	spin_lock_init(&pbc->spdif_out->start_at.lock);
+
+	link->name = link->stream_name = "pistachio-spdif-out";
+
+	np = of_parse_phandle(node, "cpu-dai", 0);
+	if (!np)
+		return -EINVAL;
+
+	link->cpu_of_node = np;
+	link->platform_of_node = np;
+	link->codec_dai_name = "snd-soc-dummy-dai";
+	link->codec_name = "snd-soc-dummy";
+	link->ops = &pistachio_card_spdif_out_ops;
+
+	return 0;
+}
+
+static int pistachio_card_parse_of_spdif_in(struct device_node *node,
+		struct pistachio_card *pbc, struct snd_soc_dai_link *link)
+{
+	struct device_node *np;
+
+	pbc->spdif_in = true;
+
+	link->name = link->stream_name = "pistachio-spdif-in";
+
+	np = of_parse_phandle(node, "cpu-dai", 0);
+	if (!np)
+		return -EINVAL;
+
+	link->cpu_of_node = np;
+	link->platform_of_node = np;
+	link->codec_dai_name = "snd-soc-dummy-dai";
+	link->codec_name = "snd-soc-dummy";
+
+	return 0;
+}
+
+static int pistachio_card_parse_of_parallel_out(struct device_node *node,
+		struct pistachio_card *pbc, struct snd_soc_dai_link *link)
+{
+	struct device_node *np;
+	int ret;
+
+	pbc->parallel_out = devm_kzalloc(pbc->card.dev,
+			sizeof(*pbc->parallel_out), GFP_KERNEL);
+	if (!pbc->parallel_out)
+		return -ENOMEM;
+
+	pbc->parallel_out->output.start_at.enable =
+			PISTACHIO_EVT_ENABLE_PARALLEL_OUT;
+	pbc->parallel_out->output.start_at.dummy_frames = 2;
+	spin_lock_init(&pbc->parallel_out->output.start_at.lock);
+
+	link->name = link->stream_name = "pistachio-parallel-out";
+
+	np = of_parse_phandle(node, "cpu-dai", 0);
+	if (!np)
+		return -EINVAL;
+
+	link->cpu_of_node = np;
+	link->platform_of_node = np;
+	link->codecs = &pbc->parallel_out->internal_dac;
+	np = of_parse_phandle(node, "sound-dai", 0);
+	if (!np)
+		return -EINVAL;
+	link->codecs[0].of_node = np;
+	link->num_codecs = 1;
+	ret = snd_soc_of_get_dai_name(node, &link->codecs[0].dai_name);
+	if (ret)
+		return ret;
+
+	link->ops = &pistachio_card_parallel_out_ops;
+
+	return 0;
+}
+
+static int pistachio_card_parse_of_i2s_mclk(struct device_node *np,
+	struct pistachio_mclk *mclk, struct pistachio_i2s_mclk_fs_info *fs)
+{
+	int ret, i, j, k, num_fs_rates;
+	u32 min_freq, max_freq, fs_rates[PISTACHIO_MAX_FS_RATES];
+
+	ret = of_property_read_u32(np, "mclk-min-freq", &min_freq);
+	if (ret)
+		return ret;
+	ret = of_property_read_u32(np, "mclk-max-freq", &max_freq);
+	if (ret)
+		return ret;
+
+	if (max_freq < PISTACHIO_MIN_MCLK_FREQ)
+		return -EINVAL;
+	if (min_freq > mclk->min_rate)
+		mclk->min_rate = min_freq;
+	if (max_freq < mclk->max_rate)
+		mclk->max_rate = max_freq;
+	if (mclk->min_rate > mclk->max_rate)
+		return -EINVAL;
+
+	num_fs_rates = of_property_count_u32_elems(np, "mclk-fs");
+	if (num_fs_rates < 0)
+		return num_fs_rates;
+	if (!num_fs_rates || (num_fs_rates > PISTACHIO_MAX_FS_RATES))
+		return -EINVAL;
+
+	ret = of_property_read_u32_array(np, "mclk-fs", fs_rates,
+						num_fs_rates);
+	if (ret)
+		return ret;
+
+	/*
+	 * If this is the first fs-rates list for this combination
+	 * of {i2s direction, mclk}, this list defines the
+	 * current fs-rate list for this combination. Else, this list
+	 * subtracts any fs-rates that are not present in both lists from the
+	 * current list for this combination
+	 */
+	if (!fs->num_fs_rates) {
+		for (i = 0; i < num_fs_rates; i++)
+			fs->fs_rates[i] = fs_rates[i];
+		fs->num_fs_rates = num_fs_rates;
+	} else {
+		for (j = 0; j < fs->num_fs_rates; j++) {
+			for (i = 0; i < num_fs_rates; i++)
+				if (fs->fs_rates[j] == fs_rates[i])
+					break;
+			if (i == num_fs_rates) {
+				for (k = j; k < (fs->num_fs_rates - 1); k++)
+					fs->fs_rates[k] = fs->fs_rates[k + 1];
+				fs->num_fs_rates--;
+				if (!fs->num_fs_rates)
+					return -EINVAL;
+				j--;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int pistachio_card_parse_of_i2s_codecs(struct device_node *np,
+			struct pistachio_card *pbc,
+			struct pistachio_i2s_codec_info *codec_info,
+			struct pistachio_i2s_mclk_fs_info *i2s_fs_info,
+			struct pistachio_i2s_mclk_fs_info *dac_fs_info)
+{
+	int i, j, ret;
+	struct device_node *subnode, *codec;
+	struct pistachio_i2s_codec_info_s *info;
+	u32 mclk_id;
+	struct pistachio_mclk *mclk;
+	struct pistachio_i2s_mclk_fs_info *fs_info;
+
+	j = 0;
+	for_each_child_of_node(np, subnode) {
+		ret = of_property_read_u32(subnode, "mclk", &mclk_id);
+		if (ret)
+			return ret;
+
+		switch (mclk_id) {
+		case PISTACHIO_MCLK_I2S:
+			mclk = &pbc->i2s_mclk;
+			fs_info = i2s_fs_info;
+			break;
+		case PISTACHIO_MCLK_DAC:
+			mclk = &pbc->dac_mclk;
+			fs_info = dac_fs_info;
+			break;
+		case PISTACHIO_MCLK_NONE:
+			mclk = NULL;
+			break;
+		default:
+			ret = -EINVAL;
+			goto err_subnode;
+		}
+		if (mclk) {
+			ret = pistachio_card_parse_of_i2s_mclk(subnode, mclk,
+								fs_info);
+			if (ret)
+				goto err_subnode;
+		}
+
+		codec = of_parse_phandle(subnode, "sound-dai", 0);
+		if (!codec)
+			continue;
+		if (codec_info->total_codecs == PISTACHIO_MAX_I2S_CODECS) {
+			ret = -EINVAL;
+			of_node_put(codec);
+			goto err_subnode;
+		}
+		for (i = 0; i < codec_info->total_codecs; i++)
+			if (codec_info->codecs[i].np == codec)
+				break;
+		if (i == codec_info->total_codecs)
+			codec_info->unique_codecs++;
+		info = &codec_info->codecs[codec_info->total_codecs++];
+		info->np = codec;
+		info->prefix = subnode->name;
+		ret = snd_soc_of_get_dai_name(subnode, &info->dai_name);
+		if (ret)
+			goto err_subnode;
+		info->mclk = mclk;
+		ret = of_property_read_u32(subnode, "mclk-index",
+						&info->mclk_index);
+		if (ret)
+			info->mclk_index = 0;
+		if (of_property_read_bool(subnode, "frame-master")) {
+			if (codec_info->frame_master_idx != -1) {
+				ret = -EINVAL;
+				goto err_subnode;
+			}
+			codec_info->frame_master_idx = j;
+		}
+		if (of_property_read_bool(subnode, "bitclock-master")) {
+			if (codec_info->bitclock_master_idx != -1) {
+				ret = -EINVAL;
+				goto err_subnode;
+			}
+			codec_info->bitclock_master_idx = j;
+		}
+		j++;
+	}
+
+	return 0;
+
+err_subnode:
+	of_node_put(subnode);
+	return ret;
+}
+
+static int pistachio_card_parse_of_i2s_common(struct device_node *node,
+	struct pistachio_card *pbc, struct pistachio_i2s *i2s,
+	struct snd_soc_dai_link *link,
+	struct pistachio_i2s_codec_info *codec_info,
+	struct pistachio_i2s_mclk_fs_info *i2s_mclk_info,
+	struct pistachio_i2s_mclk_fs_info *dac_mclk_info)
+{
+	int ret, i;
+	unsigned int initial_codecs = codec_info->total_codecs, size;
+	struct pistachio_i2s_codec_info_s *codecs;
+	struct pistachio_i2s_mclk *mclk;
+
+	codecs = &codec_info->codecs[initial_codecs];
+
+	ret = pistachio_card_parse_of_i2s_codecs(node, pbc, codec_info,
+					i2s_mclk_info, dac_mclk_info);
+	i2s->num_codecs = codec_info->total_codecs - initial_codecs;
+	if (ret)
+		goto err_codec_info;
+
+	mclk = &i2s->mclk_a;
+
+	if (i2s_mclk_info->num_fs_rates) {
+		mclk->mclk = &pbc->i2s_mclk;
+		mclk->num_fs_rates = i2s_mclk_info->num_fs_rates;
+		size = sizeof(*mclk->fs_rates) * mclk->num_fs_rates;
+		mclk->fs_rates = devm_kzalloc(pbc->card.dev, size,
+							GFP_KERNEL);
+		if (!mclk->fs_rates) {
+			ret = -ENOMEM;
+			goto err_codec_info;
+		}
+		memcpy(mclk->fs_rates, i2s_mclk_info->fs_rates, size);
+		mclk = &i2s->mclk_b;
+	}
+
+	if (dac_mclk_info->num_fs_rates) {
+		mclk->mclk = &pbc->dac_mclk;
+		mclk->num_fs_rates = dac_mclk_info->num_fs_rates;
+		size = sizeof(*mclk->fs_rates) * mclk->num_fs_rates;
+		mclk->fs_rates = devm_kzalloc(pbc->card.dev, size,
+							GFP_KERNEL);
+		if (!mclk->fs_rates) {
+			ret = -ENOMEM;
+			goto err_codec_info;
+		}
+		memcpy(mclk->fs_rates, dac_mclk_info->fs_rates, size);
+	}
+
+	if (!i2s->num_codecs) {
+		link->codec_dai_name = "snd-soc-dummy-dai";
+		link->codec_name = "snd-soc-dummy";
+		return 0;
+	}
+
+	i2s->codecs = devm_kzalloc(pbc->card.dev,
+		sizeof(*i2s->codecs) * i2s->num_codecs, GFP_KERNEL);
+	if (!i2s->codecs) {
+		ret = -ENOMEM;
+		goto err_codec_info;
+	}
+
+	for (i = 0; i < i2s->num_codecs; i++) {
+		i2s->codecs[i].mclk = codecs[i].mclk;
+		i2s->codecs[i].mclk_index = codecs[i].mclk_index;
+	}
+
+	i2s->components = devm_kzalloc(pbc->card.dev,
+		sizeof(*i2s->components) * i2s->num_codecs, GFP_KERNEL);
+	if (!i2s->components) {
+		ret = -ENOMEM;
+		goto err_codec_info;
+	}
+
+	for (i = 0; i < i2s->num_codecs; i++) {
+		i2s->components[i].dai_name = codecs[i].dai_name;
+		i2s->components[i].of_node = codecs[i].np;
+	}
+
+	link->codecs = i2s->components;
+	link->num_codecs = i2s->num_codecs;
+
+	return 0;
+
+err_codec_info:
+	for (i = 0; i < i2s->num_codecs; i++)
+		of_node_put(codecs[i].np);
+
+	return ret;
+}
+
+static int pistachio_card_parse_of_i2s(struct device_node *i2s_out_np,
+	struct device_node *i2s_in_np, struct pistachio_card *pbc,
+	struct snd_soc_dai_link *links,
+	struct pistachio_i2s_codec_info *codec_info,
+	bool i2s_loopback)
+{
+	int ret;
+	struct device *dev = pbc->card.dev;
+	unsigned int fmt;
+	struct device_node *np;
+	struct pistachio_i2s_mclk_fs_info i2s_mclk_info, dac_mclk_info;
+
+	pbc->i2s_mclk.max_rate = PISTACHIO_I2S_MCLK_MAX_FREQ;
+	pbc->dac_mclk.max_rate = PISTACHIO_DAC_MCLK_MAX_FREQ;
+
+	codec_info->bitclock_master_idx = -1;
+	codec_info->frame_master_idx = -1;
+
+	if (i2s_out_np) {
+		pbc->i2s_out = devm_kzalloc(dev, sizeof(*pbc->i2s_out),
+						GFP_KERNEL);
+		if (!pbc->i2s_out)
+			return -ENOMEM;
+
+		pbc->i2s_out->output.start_at.enable =
+				PISTACHIO_EVT_ENABLE_I2S_OUT;
+		pbc->i2s_out->output.start_at.dummy_frames = 1;
+		spin_lock_init(&pbc->i2s_out->output.start_at.lock);
+
+		links->name = links->stream_name = "pistachio-i2s-out";
+
+		np = of_parse_phandle(i2s_out_np, "cpu-dai", 0);
+		if (!np)
+			return -EINVAL;
+
+		links->cpu_of_node = np;
+		links->platform_of_node = np;
+
+		fmt = snd_soc_of_parse_daifmt(i2s_out_np, NULL, NULL, NULL);
+		fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
+		fmt |= SND_SOC_DAIFMT_CBS_CFS;
+		links->dai_fmt = fmt;
+
+		/*
+		 * Internal i2s out controller uses i2s_mclk and
+		 * accepts 256fs,384fs
+		 */
+		i2s_mclk_info.fs_rates[0] = 256;
+		i2s_mclk_info.fs_rates[1] = 384;
+		i2s_mclk_info.num_fs_rates = 2;
+		dac_mclk_info.num_fs_rates = 0;
+
+		ret = pistachio_card_parse_of_i2s_common(i2s_out_np, pbc,
+				&pbc->i2s_out->i2s, links, codec_info,
+				&i2s_mclk_info, &dac_mclk_info);
+		if (ret)
+			return ret;
+
+		links->init = pistachio_card_i2s_out_link_init;
+		links->ops = &pistachio_card_i2s_out_ops;
+
+		links++;
+	}
+
+	if (i2s_in_np) {
+		pbc->i2s_in = devm_kzalloc(dev, sizeof(*pbc->i2s_in),
+						GFP_KERNEL);
+		if (!pbc->i2s_in)
+			return -ENOMEM;
+
+		links->name = links->stream_name = "pistachio-i2s-in";
+
+		np = of_parse_phandle(i2s_in_np, "cpu-dai", 0);
+		if (!np)
+			return -EINVAL;
+
+		links->cpu_of_node = np;
+		links->platform_of_node = np;
+
+		fmt = snd_soc_of_parse_daifmt(i2s_in_np, NULL, NULL, NULL);
+		fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
+		pbc->i2s_in->fmt = fmt;
+
+		i2s_mclk_info.num_fs_rates = 0;
+		dac_mclk_info.num_fs_rates = 0;
+
+		ret = pistachio_card_parse_of_i2s_common(i2s_in_np, pbc,
+				&pbc->i2s_in->i2s, links, codec_info,
+				&i2s_mclk_info, &dac_mclk_info);
+		if (ret)
+			return ret;
+
+		if (i2s_loopback) {
+			pbc->i2s_in->frame_master =
+					PISTACHIO_CLOCK_MASTER_LOOPBACK;
+			pbc->i2s_in->bitclock_master =
+					PISTACHIO_CLOCK_MASTER_LOOPBACK;
+		} else if ((codec_info->bitclock_master_idx == -1) ||
+				(codec_info->frame_master_idx == -1)) {
+			pbc->i2s_in->frame_master =
+					PISTACHIO_CLOCK_MASTER_EXT;
+			pbc->i2s_in->bitclock_master =
+					PISTACHIO_CLOCK_MASTER_EXT;
+		} else {
+			pbc->i2s_in->frame_master =
+					codec_info->frame_master_idx;
+			pbc->i2s_in->bitclock_master =
+					codec_info->bitclock_master_idx;
+		}
+
+		links->init = pistachio_card_i2s_in_link_init;
+
+		/*
+		 * If no mclks are used by i2s in, there is nothing for
+		 * the ops callbacks to do, so leave this as NULL
+		 */
+		if (pbc->i2s_in->i2s.mclk_a.mclk)
+			links->ops = &pistachio_card_i2s_in_ops;
+	}
+
+	return 0;
+}
+
+static int pistachio_card_parse_of_confs(struct pistachio_card *pbc,
+			struct pistachio_i2s_codec_info *codec_info,
+			struct snd_soc_dai_link *parallel_out)
+{
+	int i, j, n;
+	unsigned int size;
+	struct pistachio_i2s_codec_info_s *codecs;
+	struct snd_soc_codec_conf *conf, *c;
+
+	n = codec_info->unique_codecs;
+	if (parallel_out)
+		n++;
+	codecs = codec_info->codecs;
+
+	size = sizeof(*pbc->card.codec_conf) * n;
+	pbc->card.codec_conf = devm_kzalloc(pbc->card.dev, size, GFP_KERNEL);
+	if (!pbc->card.codec_conf)
+		return -ENOMEM;
+
+	conf = pbc->card.codec_conf;
+
+	for (i = 0; i < codec_info->total_codecs; i++) {
+		for (j = 0; j < i; j++)
+			if (codecs[j].np == codecs[i].np)
+				break;
+		if (j == i) {
+			conf->of_node = codecs[i].np;
+			conf->name_prefix = codecs[i].prefix;
+			conf++;
+		}
+	}
+
+	if (parallel_out) {
+		conf->of_node = parallel_out->codecs[0].of_node;
+		conf->name_prefix = PISTACHIO_INTERNAL_DAC_PREFIX;
+	}
+
+	pbc->card.num_configs = n;
+
+	for (i = 0; i < n; i++) {
+		conf = &pbc->card.codec_conf[i];
+		for (j = i + 1; j < n; j++) {
+			c = &pbc->card.codec_conf[j];
+			if (!strcasecmp(conf->name_prefix, c->name_prefix)) {
+				dev_err(pbc->card.dev, "Prefix clash: %s\n",
+						conf->name_prefix);
+				return -EINVAL;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int pistachio_card_parse_of(struct device_node *node,
+				struct pistachio_card *pbc)
+{
+	int ret = 0;
+	struct device_node *spdif_out_np, *spdif_in_np, *parallel_out_np;
+	struct device_node *i2s_out_np, *i2s_in_np, *event_np;
+	struct snd_soc_dai_link *link, *prl_out = NULL;
+	enum of_gpio_flags flags;
+	struct pistachio_i2s_codec_info i2s_codec_info;
+	bool i2s_loopback;
+
+	pbc->periph_regs = syscon_regmap_lookup_by_phandle(node,
+						"img,cr-periph");
+	if (IS_ERR(pbc->periph_regs))
+		return PTR_ERR(pbc->periph_regs);
+
+	event_np = of_parse_phandle(node, "img,event-timer", 0);
+	if (!event_np)
+		return -EINVAL;
+	pbc->event_timer_np = event_np;
+	pbc->event_timer = pistachio_evt_get(event_np);
+	if (IS_ERR(pbc->event_timer))
+		return PTR_ERR(pbc->event_timer);
+
+	if (of_property_read_bool(node, "img,widgets")) {
+		ret = snd_soc_of_parse_audio_simple_widgets(&pbc->card,
+					"img,widgets");
+		if (ret)
+			return ret;
+	}
+
+	if (of_property_read_bool(node, "img,routing")) {
+		ret = snd_soc_of_parse_audio_routing(&pbc->card,
+					"img,routing");
+		if (ret)
+			return ret;
+	}
+
+	spdif_out_np = of_get_child_by_name(node, "spdif-out");
+	if (spdif_out_np)
+		pbc->card.num_links++;
+
+	spdif_in_np = of_get_child_by_name(node, "spdif-in");
+	if (spdif_in_np)
+		pbc->card.num_links++;
+
+	parallel_out_np = of_get_child_by_name(node, "parallel-out");
+	if (parallel_out_np)
+		pbc->card.num_links++;
+
+	i2s_out_np = of_get_child_by_name(node, "i2s-out");
+	if (i2s_out_np)
+		pbc->card.num_links++;
+
+	i2s_in_np = of_get_child_by_name(node, "i2s-in");
+	if (i2s_in_np)
+		pbc->card.num_links++;
+
+	i2s_loopback = of_property_read_bool(node, "img,i2s-clk-loopback");
+	if (i2s_loopback && (!i2s_out_np || !i2s_in_np)) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	if (!pbc->card.num_links) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	pbc->card.dai_link = devm_kzalloc(pbc->card.dev,
+		sizeof(*pbc->card.dai_link) * pbc->card.num_links, GFP_KERNEL);
+	if (!pbc->card.dai_link) {
+		ret = -ENOMEM;
+		goto end;
+	}
+
+	i2s_codec_info.total_codecs = 0;
+	i2s_codec_info.unique_codecs = 0;
+
+	link = pbc->card.dai_link;
+
+	if (spdif_out_np) {
+		ret = pistachio_card_parse_of_spdif_out(spdif_out_np, pbc,
+							link);
+		if (ret)
+			goto end;
+		link++;
+	}
+
+	if (spdif_in_np) {
+		ret = pistachio_card_parse_of_spdif_in(spdif_in_np, pbc,
+							link);
+		if (ret)
+			goto end;
+		link++;
+	}
+
+	if (parallel_out_np) {
+		ret = pistachio_card_parse_of_parallel_out(parallel_out_np,
+								pbc, link);
+		if (ret)
+			goto end;
+		prl_out = link;
+		link++;
+	}
+
+	if (i2s_out_np || i2s_in_np) {
+		ret = pistachio_card_parse_of_i2s(i2s_out_np, i2s_in_np, pbc,
+					link, &i2s_codec_info, i2s_loopback);
+		if (ret)
+			goto end;
+	}
+
+	ret = pistachio_card_parse_of_confs(pbc, &i2s_codec_info, prl_out);
+	if (ret)
+		goto end;
+
+	pbc->hp_jack_gpio.gpio = of_get_named_gpio_flags(node,
+					"img,hp-det-gpio", 0, &flags);
+	pbc->hp_jack_gpio.invert = !!(flags & OF_GPIO_ACTIVE_LOW);
+	if (pbc->hp_jack_gpio.gpio == -EPROBE_DEFER) {
+		ret = -EPROBE_DEFER;
+		goto end;
+	}
+
+	pbc->mute_gpio = of_get_named_gpio_flags(node, "img,mute-gpio", 0,
+						&flags);
+	pbc->mute_gpio_inverted = !!(flags & OF_GPIO_ACTIVE_LOW);
+	if (pbc->mute_gpio_inverted == -EPROBE_DEFER) {
+		ret = -EPROBE_DEFER;
+		goto end;
+	}
+
+end:
+	if (spdif_out_np)
+		of_node_put(spdif_out_np);
+	if (spdif_in_np)
+		of_node_put(spdif_in_np);
+	if (parallel_out_np)
+		of_node_put(parallel_out_np);
+	if (i2s_out_np)
+		of_node_put(i2s_out_np);
+	if (i2s_in_np)
+		of_node_put(i2s_in_np);
+
+	return ret;
+}
+
+static void pistachio_card_unref(struct pistachio_card *pbc)
+{
+	int i, j;
+	struct snd_soc_dai_link *link;
+
+	if (pbc->event_timer_np)
+		of_node_put(pbc->event_timer_np);
+
+	link = pbc->card.dai_link;
+	if (!link)
+		return;
+
+	for (i = 0; i < pbc->card.num_links; i++, link++) {
+		if (link->cpu_of_node)
+			of_node_put(link->cpu_of_node);
+		for (j = 0; j < link->num_codecs; j++)
+			of_node_put(link->codecs[j].of_node);
+	}
+}
+
+static int pistachio_card_init_clk(struct device *dev, char *name,
+					struct clk **pclk)
+{
+	struct clk *clk;
+	int ret;
+
+	clk = devm_clk_get(dev, name);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	ret = clk_prepare_enable(clk);
+	if (ret)
+		return ret;
+
+	*pclk = clk;
+
+	return 0;
+}
+
+static int pistachio_card_init_rates(struct pistachio_card *pbc)
+{
+	unsigned int rate;
+	int ret;
+
+	rate = PISTACHIO_PLL_RATE_B;
+	ret = clk_set_rate(pbc->audio_pll, rate);
+	if (ret)
+		return ret;
+	pbc->audio_pll_rate = rate;
+
+	rate = PISTACHIO_MIN_MCLK_FREQ;
+	ret = clk_set_rate(pbc->i2s_mclk.mclk, rate);
+	if (ret)
+		return ret;
+	pbc->i2s_mclk.cur_rate = rate;
+	ret = clk_set_rate(pbc->dac_mclk.mclk, rate);
+	if (ret)
+		return ret;
+	pbc->dac_mclk.cur_rate = rate;
+
+	return 0;
+}
+
+static int pistachio_card_info_timespec(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = LONG_MAX;
+
+	return 0;
+}
+
+static int pistachio_card_get_event_time(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *uc)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	struct timespec ts;
+
+	pistachio_evt_get_time_ts(pbc->event_timer, &ts);
+
+	uc->value.integer.value[0] = ts.tv_sec;
+	uc->value.integer.value[1] = ts.tv_nsec;
+
+	return 0;
+}
+
+static int pistachio_card_info_source(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = PISTACHIO_EVT_NUM_SOURCES - 1;
+
+	return 0;
+}
+
+static int pistachio_card_set_source(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol,
+				  int id)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+
+	return pistachio_evt_set_source(pbc->event_timer, id,
+		ucontrol->value.integer.value[0]);
+}
+
+static int pistachio_card_set_source_a(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_set_source(kcontrol, ucontrol, 0);
+}
+
+static int pistachio_card_set_source_b(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_set_source(kcontrol, ucontrol, 1);
+}
+
+static int pistachio_card_get_source(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol,
+				  int id)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	enum pistachio_evt_source source;
+	int ret;
+
+	ret = pistachio_evt_get_source(pbc->event_timer, id, &source);
+
+	if (!ret)
+		ucontrol->value.integer.value[0] = source;
+
+	return ret;
+}
+
+static int pistachio_card_get_source_a(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_source(kcontrol, ucontrol, 0);
+}
+
+static int pistachio_card_get_source_b(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_source(kcontrol, ucontrol, 1);
+}
+
+void pistachio_card_sample_rate_notify(int id, void *context)
+{
+	struct pistachio_card *pbc = context;
+
+	if (pbc->sample_rate_ids[id])
+		snd_ctl_notify(pbc->card.snd_card, SNDRV_CTL_EVENT_MASK_VALUE,
+				pbc->sample_rate_ids[id]);
+}
+
+void pistachio_card_sample_rate_notify_a(void *context)
+{
+	pistachio_card_sample_rate_notify(0, context);
+}
+
+void pistachio_card_sample_rate_notify_b(void *context)
+{
+	pistachio_card_sample_rate_notify(1, context);
+}
+
+void pistachio_card_phase_difference_notify(void *context)
+{
+	struct pistachio_card *pbc = context;
+
+	if (pbc->phase_difference_id)
+		snd_ctl_notify(pbc->card.snd_card, SNDRV_CTL_EVENT_MASK_VALUE,
+				pbc->phase_difference_id);
+}
+
+static int pistachio_card_get_sample_period(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol,
+				  int id)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+	u32 val, freq, nsec;
+	u64 temp;
+
+	pbc->sample_rate_ids[id] = &kcontrol->id;
+
+	ret = pistachio_evt_get_sample_rate(pbc->event_timer, id, &val, &freq,
+				pistachio_card_sample_rate_notify_a, pbc);
+
+	if (!ret) {
+		temp = ((u64)val * NSEC_PER_SEC) + (freq / 2);
+		do_div(temp, freq);
+		nsec = do_div(temp, NSEC_PER_SEC);
+		ucontrol->value.integer.value[0] = temp;
+		ucontrol->value.integer.value[1] = nsec;
+	}
+
+	return ret;
+}
+
+static int pistachio_card_get_sample_period_a(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_sample_period(kcontrol, ucontrol, 0);
+}
+
+static int pistachio_card_get_sample_period_b(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_sample_period(kcontrol, ucontrol, 1);
+}
+
+static int pistachio_card_info_sample_rate(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = LONG_MAX;
+
+	return 0;
+}
+
+static int pistachio_card_get_sample_rate(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol,
+				  int id)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+	u32 val, freq, rate;
+
+	pbc->sample_rate_ids[id] = &kcontrol->id;
+
+	ret = pistachio_evt_get_sample_rate(pbc->event_timer, id, &val, &freq,
+				pistachio_card_sample_rate_notify_b, pbc);
+
+	if (!ret) {
+		if (!val)
+			return -EINVAL;
+		rate = DIV_ROUND_CLOSEST(freq, val);
+		ucontrol->value.integer.value[0] = rate;
+	}
+
+	return ret;
+}
+
+static int pistachio_card_get_sample_rate_a(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_sample_rate(kcontrol, ucontrol, 0);
+}
+
+static int pistachio_card_get_sample_rate_b(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_sample_rate(kcontrol, ucontrol, 1);
+}
+
+static int pistachio_card_get_phase_difference(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+	u32 val, freq, nsec;
+	u64 temp;
+
+	pbc->phase_difference_id = &kcontrol->id;
+
+	ret = pistachio_evt_get_phase_difference(pbc->event_timer, &val,
+			&freq, pistachio_card_phase_difference_notify, pbc);
+
+	if (!ret) {
+		temp = ((u64)val * NSEC_PER_SEC) + (freq / 2);
+		do_div(temp, freq);
+		nsec = do_div(temp, NSEC_PER_SEC);
+		ucontrol->value.integer.value[0] = temp;
+		ucontrol->value.integer.value[1] = nsec;
+	}
+
+	return ret;
+}
+
+static int pistachio_card_get_mute(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+
+	ret = gpio_get_value_cansleep(pbc->mute_gpio);
+	if (ret < 0)
+		return ret;
+	else if (pbc->mute_gpio_inverted)
+		ucontrol->value.integer.value[0] = !ret;
+	else
+		ucontrol->value.integer.value[0] = !!ret;
+
+	return 0;
+}
+
+static int pistachio_card_set_mute(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int val;
+
+	if (pbc->mute_gpio_inverted)
+		val = !ucontrol->value.integer.value[0];
+	else
+		val = ucontrol->value.integer.value[0];
+
+	gpio_set_value_cansleep(pbc->mute_gpio, val);
+
+	return 0;
+}
+
+static int pistachio_card_info_sample_rates(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 192000;
+
+	return 0;
+}
+
+static int pistachio_card_set_sample_rates_mclk(struct pistachio_card *pbc,
+		struct pistachio_mclk *mclk, unsigned int i2s_out_rate,
+		unsigned int i2s_in_rate)
+{
+	struct pistachio_i2s_mclk *mclk_a, *mclk_b;
+	unsigned int rate_a, rate_b;
+	int ret = 0;
+
+	mclk_a = NULL;
+	mclk_b = NULL;
+	rate_a = i2s_out_rate;
+	rate_b = i2s_in_rate;
+
+	if (i2s_out_rate) {
+		if (pbc->i2s_out->i2s.mclk_a.mclk == mclk)
+			mclk_a = &pbc->i2s_out->i2s.mclk_a;
+		else if (pbc->i2s_out->i2s.mclk_b.mclk == mclk)
+			mclk_a = &pbc->i2s_out->i2s.mclk_b;
+	}
+	if (i2s_in_rate) {
+		if (pbc->i2s_in->i2s.mclk_a.mclk == mclk)
+			mclk_b = &pbc->i2s_in->i2s.mclk_a;
+		else if (pbc->i2s_in->i2s.mclk_b.mclk == mclk)
+			mclk_b = &pbc->i2s_in->i2s.mclk_b;
+	}
+	if (!mclk_a) {
+		mclk_a = mclk_b;
+		rate_a = rate_b;
+		mclk_b = NULL;
+	}
+
+	if (mclk_a) {
+		ret = pistachio_card_update_mclk(pbc, mclk_a, mclk_b, rate_a,
+						rate_b);
+	}
+
+	return ret;
+}
+
+static int pistachio_card_set_sample_rates(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+	unsigned int pll_rate, i2s_out_rate = 0, i2s_in_rate = 0;
+
+	if (pbc->i2s_out)
+		i2s_out_rate = ucontrol->value.integer.value[0];
+	if (pbc->i2s_in && pbc->i2s_in->i2s.mclk_a.mclk)
+		i2s_in_rate = ucontrol->value.integer.value[1];
+
+	if (!i2s_out_rate && !i2s_in_rate)
+		return 0;
+
+	pll_rate = 0;
+
+	if (i2s_out_rate) {
+		ret = pistachio_card_get_pll_rate(i2s_out_rate);
+		if (ret < 0)
+			return ret;
+		pll_rate = ret;
+	}
+
+	if (i2s_in_rate) {
+		ret = pistachio_card_get_pll_rate(i2s_in_rate);
+		if (ret < 0)
+			return ret;
+		if (pll_rate && (ret != pll_rate))
+			return -EINVAL;
+		pll_rate = ret;
+	}
+
+	mutex_lock(&pbc->rate_mutex);
+
+	if (pbc->audio_pll_rate != pll_rate) {
+		ret = pistachio_card_set_pll_rate(pbc, pll_rate);
+		if (ret) {
+			mutex_unlock(&pbc->rate_mutex);
+			return ret;
+		}
+	}
+
+	ret = pistachio_card_set_sample_rates_mclk(pbc, &pbc->i2s_mclk,
+						i2s_out_rate, i2s_in_rate);
+	if (ret) {
+		mutex_unlock(&pbc->rate_mutex);
+		return ret;
+	}
+
+	ret = pistachio_card_set_sample_rates_mclk(pbc, &pbc->dac_mclk,
+						i2s_out_rate, i2s_in_rate);
+
+	mutex_unlock(&pbc->rate_mutex);
+
+	return ret;
+}
+
+static struct snd_kcontrol_new pistachio_controls[] = {
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Event Time",
+		.info = pistachio_card_info_timespec,
+		.get = pistachio_card_get_event_time
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Measurement Source A",
+		.info = pistachio_card_info_source,
+		.get = pistachio_card_get_source_a,
+		.put = pistachio_card_set_source_a
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Measurement Source B",
+		.info = pistachio_card_info_source,
+		.get = pistachio_card_get_source_b,
+		.put = pistachio_card_set_source_b
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Sample Rate A",
+		.info = pistachio_card_info_sample_rate,
+		.get = pistachio_card_get_sample_rate_a,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Sample Rate B",
+		.info = pistachio_card_info_sample_rate,
+		.get = pistachio_card_get_sample_rate_b,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Sample Period A",
+		.info = pistachio_card_info_timespec,
+		.get = pistachio_card_get_sample_period_a,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Sample Period B",
+		.info = pistachio_card_info_timespec,
+		.get = pistachio_card_get_sample_period_b,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Phase Difference",
+		.info = pistachio_card_info_timespec,
+		.get = pistachio_card_get_phase_difference,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_WRITE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "I2S Rates",
+		.info = pistachio_card_info_sample_rates,
+		.put = pistachio_card_set_sample_rates
+	},
+};
+
+#ifdef DEBUG
+
+static void pistachio_card_info_mclk(struct pistachio_card *pbc,
+					struct pistachio_i2s_mclk *mclk)
+{
+	struct device *dev = pbc->card.dev;
+	int i;
+
+	dev_dbg(dev, "        Min Freq: %u\n", mclk->mclk->min_rate);
+	dev_dbg(dev, "        Max Freq: %u\n", mclk->mclk->max_rate);
+	dev_dbg(dev, "        FS Rates:\n");
+
+	for (i = 0; i < mclk->num_fs_rates; i++)
+		dev_dbg(dev, "            %u\n", mclk->fs_rates[i]);
+}
+
+static void pistachio_card_info_mclks(struct pistachio_card *pbc,
+					struct pistachio_i2s *i2s)
+{
+	struct pistachio_i2s_mclk *i2s_mclk;
+	struct pistachio_i2s_mclk *dac_mclk;
+	struct device *dev = pbc->card.dev;
+
+	if (i2s->mclk_a.mclk == &pbc->i2s_mclk)
+		i2s_mclk = &i2s->mclk_a;
+	else if (pbc->i2s_in->i2s.mclk_b.mclk == &pbc->i2s_mclk)
+		i2s_mclk = &i2s->mclk_b;
+	else
+		i2s_mclk = NULL;
+
+	if (i2s_mclk) {
+		dev_dbg(dev, "    I2S MCLK\n");
+		pistachio_card_info_mclk(pbc, i2s_mclk);
+	} else {
+		dev_dbg(dev, "    I2S MCLK NOT USED\n");
+	}
+
+	dev_dbg(dev, "\n");
+
+	if (i2s->mclk_a.mclk == &pbc->dac_mclk)
+		dac_mclk = &i2s->mclk_a;
+	else if (i2s->mclk_b.mclk == &pbc->dac_mclk)
+		dac_mclk = &i2s->mclk_b;
+	else
+		dac_mclk = NULL;
+
+	if (dac_mclk) {
+		dev_dbg(dev, "    DAC MCLK\n");
+		pistachio_card_info_mclk(pbc, dac_mclk);
+	} else {
+		dev_dbg(dev, "    DAC MCLK NOT USED\n");
+	}
+}
+
+static void pistachio_card_info_i2s_out(struct pistachio_card *pbc,
+					struct snd_soc_dai_link *link)
+{
+	int i, j;
+	struct snd_soc_dai_link_component *components;
+	struct snd_soc_codec_conf *confs;
+	struct device *dev = pbc->card.dev;
+	char *text;
+
+	components = pbc->i2s_out->i2s.components;
+	confs = pbc->card.codec_conf;
+
+	dev_dbg(dev, "I2S OUT\n");
+	dev_dbg(dev, "\n");
+	if (pbc->i2s_in && (pbc->i2s_in->frame_master ==
+			PISTACHIO_CLOCK_MASTER_LOOPBACK))
+		text = "(Dual Frame + Bit Clock Master)";
+	else
+		text = "(Frame + Bit Clock Master)";
+	dev_dbg(dev, "    CPU DAI\n");
+	dev_dbg(dev, "        i2s-out (%s) %s\n",
+		link->cpu_of_node->name, text);
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "    CODECS\n");
+
+	for (i = 0; i < pbc->i2s_out->i2s.num_codecs; i++) {
+		for (j = 0; j < pbc->card.num_configs; j++)
+			if (confs[j].of_node == components[i].of_node)
+				break;
+
+		dev_dbg(dev, "        %s (%s) (%s)\n", confs[j].name_prefix,
+			confs[j].of_node->name,
+			components[i].dai_name);
+	}
+	dev_dbg(dev, "\n");
+
+	pistachio_card_info_mclks(pbc, &pbc->i2s_out->i2s);
+
+	dev_dbg(dev, "\n");
+
+	if ((link->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S)
+		text = "I2S";
+	else
+		text = "Left Justified";
+	dev_dbg(dev, "    Format: %s\n", text);
+
+	if ((link->dai_fmt & SND_SOC_DAIFMT_CLOCK_MASK) == SND_SOC_DAIFMT_CONT)
+		text = "Yes";
+	else
+		text = "No";
+	dev_dbg(dev, "    Continuous Clock: %s\n", text);
+
+	dev_dbg(dev, "\n");
+}
+
+static void pistachio_card_info_i2s_in(struct pistachio_card *pbc,
+					struct snd_soc_dai_link *link)
+{
+	int i, j;
+	struct snd_soc_dai_link_component *components;
+	struct snd_soc_codec_conf *confs;
+	char *text;
+	struct device *dev = pbc->card.dev;
+
+	components = pbc->i2s_in->i2s.components;
+	confs = pbc->card.codec_conf;
+
+	dev_dbg(dev, "I2S IN\n");
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "    CPU DAI\n");
+	dev_dbg(dev, "        i2s-in (%s)\n",
+		link->cpu_of_node->name);
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "    CODECS\n");
+
+	for (i = 0; i < pbc->i2s_out->i2s.num_codecs; i++) {
+		for (j = 0; j < pbc->card.num_configs; j++)
+			if (confs[j].of_node == components[i].of_node)
+				break;
+
+		if (i == pbc->i2s_in->frame_master)
+			if (i == pbc->i2s_in->bitclock_master)
+				text = "(Frame + Bit Clock Master)";
+			else
+				text = "(Frame Master)";
+		else
+			if (i == pbc->i2s_in->bitclock_master)
+				text = "(Bitclock Master)";
+			else
+				text = "";
+
+		dev_dbg(dev, "        %s (%s) (%s) %s\n", confs[j].name_prefix,
+			confs[j].of_node->name,
+			components[i].dai_name, text);
+	}
+	dev_dbg(dev, "\n");
+
+	pistachio_card_info_mclks(pbc, &pbc->i2s_in->i2s);
+
+	dev_dbg(dev, "\n");
+
+	if ((pbc->i2s_in->fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==
+			SND_SOC_DAIFMT_I2S)
+		text = "I2S";
+	else
+		text = "Left Justified";
+	dev_dbg(dev, "    Format: %s\n", text);
+
+	if ((pbc->i2s_in->fmt & SND_SOC_DAIFMT_CLOCK_MASK) ==
+			SND_SOC_DAIFMT_CONT)
+		text = "Yes";
+	else
+		text = "No";
+	dev_dbg(dev, "    Continuous Clock: %s\n", text);
+
+	dev_dbg(dev, "\n");
+}
+
+static void pistachio_card_info(struct pistachio_card *pbc)
+{
+	struct device *dev = pbc->card.dev;
+	struct snd_soc_codec_conf *conf;
+	struct snd_soc_dai_link *link;
+	char *text;
+
+	link = pbc->card.dai_link;
+
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "####################################################\n");
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "Pistachio Audio Card\n");
+	dev_dbg(dev, "\n");
+
+	if (pbc->spdif_out) {
+		dev_dbg(dev, "SPDIF OUT\n");
+		dev_dbg(dev, "\n");
+		dev_dbg(dev, "    CPU DAI\n");
+		dev_dbg(dev, "        spdif-out (%s)\n",
+			link->cpu_of_node->name);
+		dev_dbg(dev, "\n");
+		link++;
+	}
+	if (pbc->spdif_in) {
+		dev_dbg(dev, "SPDIF IN\n");
+		dev_dbg(dev, "\n");
+		dev_dbg(dev, "    CPU DAI\n");
+		dev_dbg(dev, "        spdif-in (%s)\n",
+			link->cpu_of_node->name);
+		dev_dbg(dev, "\n");
+		link++;
+	}
+	if (pbc->parallel_out) {
+		dev_dbg(dev, "PARALLEL OUT\n");
+		dev_dbg(dev, "\n");
+		dev_dbg(dev, "    CPU DAI\n");
+		dev_dbg(dev, "        parallel-out (%s)\n",
+			link->cpu_of_node->name);
+		dev_dbg(dev, "\n");
+		dev_dbg(dev, "    CODECS\n");
+		conf = &pbc->card.codec_conf[pbc->card.num_configs - 1];
+		dev_dbg(dev, "        %s (%s) (%s)\n", conf->name_prefix,
+			conf->of_node->name,
+			pbc->parallel_out->internal_dac.dai_name);
+		dev_dbg(dev, "\n");
+		link++;
+	}
+	if (pbc->i2s_out) {
+		pistachio_card_info_i2s_out(pbc, link);
+		link++;
+	}
+
+	if (pbc->i2s_in)
+		pistachio_card_info_i2s_in(pbc, link);
+
+	if (gpio_is_valid(pbc->mute_gpio)) {
+		if (pbc->mute_gpio_inverted)
+			text = "(Active Low)";
+		else
+			text = "(Active High)";
+		dev_dbg(dev, "Mute: GPIO %u %s\n", pbc->mute_gpio, text);
+	}
+	if (gpio_is_valid(pbc->hp_jack_gpio.gpio)) {
+		if (pbc->hp_jack_gpio.invert)
+			text = "(Active Low)";
+		else
+			text = "(Active High)";
+		dev_dbg(dev, "Headphone-Detect: GPIO %u %s\n",
+				pbc->hp_jack_gpio.gpio, text);
+	}
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "####################################################\n");
+	dev_dbg(dev, "\n");
+}
+
+#endif
+
+static int pistachio_card_probe(struct platform_device *pdev)
+{
+	struct pistachio_card *pbc;
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	int ret;
+	unsigned long gpio_flags;
+	struct snd_kcontrol_new *control;
+
+	if (!np || !of_device_is_available(np))
+		return -EINVAL;
+
+	pbc = devm_kzalloc(dev, sizeof(*pbc), GFP_KERNEL);
+	if (!pbc)
+		return -ENOMEM;
+
+	pbc->card.owner = THIS_MODULE;
+	pbc->card.dev = dev;
+	pbc->card.name = "pistachio-card";
+
+	snd_soc_card_set_drvdata(&pbc->card, pbc);
+
+	mutex_init(&pbc->rate_mutex);
+
+	pbc->hp_jack_gpio.gpio = -ENOENT;
+	pbc->mute_gpio = -ENOENT;
+
+	ret = pistachio_card_parse_of(np, pbc);
+	if (ret)
+		goto err;
+
+	ret = pistachio_card_init_clk(dev, "audio_pll", &pbc->audio_pll);
+	if (ret)
+		goto err;
+
+	ret = pistachio_card_init_clk(dev, "i2s_mclk", &pbc->i2s_mclk.mclk);
+	if (ret)
+		goto err_clk_audio_pll;
+
+	ret = pistachio_card_init_clk(dev, "dac_clk", &pbc->dac_mclk.mclk);
+	if (ret)
+		goto err_clk_i2s;
+
+	ret = pistachio_card_init_rates(pbc);
+	if (ret)
+		goto err_clk_dac;
+
+	pbc->i2s_clk_notifier.notifier_call = pistachio_card_i2s_clk_cb;
+	ret = clk_notifier_register(pbc->i2s_mclk.mclk,
+					&pbc->i2s_clk_notifier);
+	if (ret)
+		goto err_clk_dac;
+
+	ret = devm_snd_soc_register_card(dev, &pbc->card);
+	if (ret)
+		goto err_notifier;
+
+	ret = snd_soc_add_card_controls(&pbc->card, pistachio_controls,
+					ARRAY_SIZE(pistachio_controls));
+	if (ret)
+		goto err_notifier;
+
+	if (gpio_is_valid(pbc->hp_jack_gpio.gpio)) {
+		pbc->hp_jack_pin.pin = "Headphones";
+		pbc->hp_jack_pin.mask = SND_JACK_HEADPHONE;
+		pbc->hp_jack_gpio.name = "Headphone detection";
+		pbc->hp_jack_gpio.report = SND_JACK_HEADPHONE;
+		pbc->hp_jack_gpio.debounce_time = 150;
+		ret = snd_soc_card_jack_new(&pbc->card, "Headphones",
+			SND_JACK_HEADPHONE, &pbc->hp_jack, &pbc->hp_jack_pin,
+			1);
+		if (ret)
+			goto err_notifier;
+		ret = snd_soc_jack_add_gpios(&pbc->hp_jack, 1,
+				&pbc->hp_jack_gpio);
+		if (ret)
+			goto err_notifier;
+	}
+
+	if (gpio_is_valid(pbc->mute_gpio)) {
+		if (pbc->mute_gpio_inverted)
+			gpio_flags = GPIOF_OUT_INIT_HIGH;
+		else
+			gpio_flags = GPIOF_OUT_INIT_LOW;
+		ret = gpio_request_one(pbc->mute_gpio, gpio_flags, "Mute");
+		if (ret)
+			goto err_jack;
+		control = devm_kzalloc(dev, sizeof(*control), GFP_KERNEL);
+		if (!control) {
+			ret = -ENOMEM;
+			goto err_mute;
+		}
+		control->access = SNDRV_CTL_ELEM_ACCESS_READWRITE;
+		control->iface = SNDRV_CTL_ELEM_IFACE_CARD;
+		control->name = "Mute Switch";
+		control->info = snd_ctl_boolean_mono_info;
+		control->get = pistachio_card_get_mute;
+		control->put = pistachio_card_set_mute;
+		ret = snd_soc_add_card_controls(&pbc->card, control, 1);
+		if (ret)
+			goto err_mute;
+	}
+
+#ifdef	DEBUG
+	pistachio_card_info(pbc);
+#endif
+
+	return 0;
+
+err_mute:
+	if (gpio_is_valid(pbc->mute_gpio))
+		gpio_free(pbc->mute_gpio);
+err_jack:
+	if (gpio_is_valid(pbc->hp_jack_gpio.gpio))
+		snd_soc_jack_free_gpios(&pbc->hp_jack, 1, &pbc->hp_jack_gpio);
+err_notifier:
+	clk_notifier_unregister(pbc->i2s_mclk.mclk, &pbc->i2s_clk_notifier);
+err_clk_dac:
+	clk_disable_unprepare(pbc->dac_mclk.mclk);
+err_clk_i2s:
+	clk_disable_unprepare(pbc->i2s_mclk.mclk);
+err_clk_audio_pll:
+	clk_disable_unprepare(pbc->audio_pll);
+err:
+	pistachio_card_unref(pbc);
+
+	return ret;
+}
+
+static int pistachio_card_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+
+	pistachio_evt_abort_measurements(pbc->event_timer);
+	if (gpio_is_valid(pbc->mute_gpio))
+		gpio_free(pbc->mute_gpio);
+	if (gpio_is_valid(pbc->hp_jack_gpio.gpio))
+		snd_soc_jack_free_gpios(&pbc->hp_jack, 1, &pbc->hp_jack_gpio);
+	clk_notifier_unregister(pbc->i2s_mclk.mclk, &pbc->i2s_clk_notifier);
+	clk_disable_unprepare(pbc->dac_mclk.mclk);
+	clk_disable_unprepare(pbc->i2s_mclk.mclk);
+	clk_disable_unprepare(pbc->audio_pll);
+	pistachio_card_unref(pbc);
+
+	return 0;
+}
+
+static const struct of_device_id pistachio_card_of_match[] = {
+	{ .compatible = "img,pistachio-audio" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, pistachio_card_of_match);
+
+static struct platform_driver pistachio_card = {
+	.driver = {
+		.name = "pistachio-card",
+		.of_match_table = pistachio_card_of_match,
+	},
+	.probe = pistachio_card_probe,
+	.remove = pistachio_card_remove,
+};
+module_platform_driver(pistachio_card);
+
+MODULE_DESCRIPTION("Pistachio audio card driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
--- a/sound/soc/soc-generic-dmaengine-pcm.c
+++ b/sound/soc/soc-generic-dmaengine-pcm.c
@@ -35,6 +35,7 @@ struct dmaengine_pcm {
 	const struct snd_dmaengine_pcm_config *config;
 	struct snd_soc_platform platform;
 	unsigned int flags;
+	bool dma_pre_started;
 };
 
 static struct dmaengine_pcm *soc_platform_to_pcm(struct snd_soc_platform *p)
@@ -318,14 +319,90 @@ static snd_pcm_uframes_t dmaengine_pcm_p
 		return snd_dmaengine_pcm_pointer(substream);
 }
 
+int dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dma_chan *dma_chan = snd_dmaengine_pcm_get_chan(substream);
+	int ret;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if(!pcm->dma_pre_started) {
+			ret = dmaengine_pcm_prepare_and_submit(substream);
+			if (ret)
+				return ret;
+			dma_async_issue_pending(dma_chan);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->runtime->hw.info & SNDRV_PCM_INFO_RESUME)
+			dmaengine_resume(dma_chan);
+		else
+			return -ENOSYS;
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->runtime->hw.info & SNDRV_PCM_INFO_PAUSE)
+			dmaengine_pause(dma_chan);
+		else
+			dmaengine_terminate_all(dma_chan);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		dmaengine_terminate_all(dma_chan);
+		pcm->dma_pre_started = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dmaengine_start_at(struct snd_pcm_substream *substream,
+	int audio_clock_type, const struct timespec *ts)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dma_chan *dma_chan = snd_dmaengine_pcm_get_chan(substream);
+	int ret;
+
+	if(pcm->flags & SND_DMAENGINE_PCM_FLAG_EARLY_START) {
+		ret = dmaengine_pcm_prepare_and_submit(substream);
+		if (ret)
+			return ret;
+		dma_async_issue_pending(dma_chan);
+		pcm->dma_pre_started = true;
+	}
+
+	return 0;
+}
+
+static int dmaengine_start_at_abort(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dma_chan *dma_chan = snd_dmaengine_pcm_get_chan(substream);
+
+	if(pcm->dma_pre_started) {
+		dmaengine_terminate_all(dma_chan);
+		pcm->dma_pre_started = false;
+	}
+
+	return 0;
+}
+
 static const struct snd_pcm_ops dmaengine_pcm_ops = {
 	.open		= dmaengine_pcm_open,
 	.close		= snd_dmaengine_pcm_close,
 	.ioctl		= snd_pcm_lib_ioctl,
 	.hw_params	= dmaengine_pcm_hw_params,
 	.hw_free	= snd_pcm_lib_free_pages,
-	.trigger	= snd_dmaengine_pcm_trigger,
+	.trigger	= dmaengine_pcm_trigger,
 	.pointer	= dmaengine_pcm_pointer,
+	.start_at	= dmaengine_start_at,
+	.start_at_abort = dmaengine_start_at_abort
 };
 
 static const struct snd_soc_platform_driver dmaengine_pcm_platform = {
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@ -1072,6 +1072,91 @@ static int soc_pcm_bespoke_trigger(struc
 	}
 	return 0;
 }
+
+static int soc_pcm_start_at(struct snd_pcm_substream *substream,
+	int audio_clock_type, const struct timespec *start_time)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai;
+	int i, ret;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		codec_dai = rtd->codec_dais[i];
+		if (codec_dai->driver->ops &&
+		    codec_dai->driver->ops->start_at) {
+			ret = codec_dai->driver->ops->start_at(substream,
+				codec_dai, audio_clock_type, start_time);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	if (platform->driver->ops && platform->driver->ops->start_at) {
+		ret = platform->driver->ops->start_at(substream,
+					audio_clock_type, start_time);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (cpu_dai->driver->ops && cpu_dai->driver->ops->start_at) {
+		ret = cpu_dai->driver->ops->start_at(substream,
+			cpu_dai, audio_clock_type, start_time);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (rtd->dai_link->ops && rtd->dai_link->ops->start_at) {
+		ret = rtd->dai_link->ops->start_at(substream,
+			audio_clock_type, start_time);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int soc_pcm_start_at_abort(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai;
+	int i, ret;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		codec_dai = rtd->codec_dais[i];
+		if (codec_dai->driver->ops &&
+		    codec_dai->driver->ops->start_at_abort) {
+			ret = codec_dai->driver->ops->start_at_abort(
+				substream, codec_dai);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	if (platform->driver->ops && platform->driver->ops->start_at_abort) {
+		ret = platform->driver->ops->start_at_abort(substream);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (cpu_dai->driver->ops && cpu_dai->driver->ops->start_at_abort) {
+		ret = cpu_dai->driver->ops->start_at_abort(substream, cpu_dai);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (rtd->dai_link->ops && rtd->dai_link->ops->start_at_abort) {
+		ret = rtd->dai_link->ops->start_at_abort(substream);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
 /*
  * soc level wrapper for pointer callback
  * If cpu_dai, codec_dai, platform driver has the delay callback, than
@@ -2617,6 +2702,8 @@ int soc_new_pcm(struct snd_soc_pcm_runti
 		rtd->ops.close		= dpcm_fe_dai_close;
 		rtd->ops.pointer	= soc_pcm_pointer;
 		rtd->ops.ioctl		= soc_pcm_ioctl;
+		rtd->ops.start_at	= soc_pcm_start_at;
+		rtd->ops.start_at_abort	= soc_pcm_start_at_abort;
 	} else {
 		rtd->ops.open		= soc_pcm_open;
 		rtd->ops.hw_params	= soc_pcm_hw_params;
@@ -2626,6 +2713,8 @@ int soc_new_pcm(struct snd_soc_pcm_runti
 		rtd->ops.close		= soc_pcm_close;
 		rtd->ops.pointer	= soc_pcm_pointer;
 		rtd->ops.ioctl		= soc_pcm_ioctl;
+		rtd->ops.start_at	= soc_pcm_start_at;
+		rtd->ops.start_at_abort	= soc_pcm_start_at_abort;
 	}
 
 	if (platform->driver->ops) {
